<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GT的博客</title>
  
  <subtitle>树欲静而风不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cotcloud.cn/"/>
  <updated>2019-01-15T08:36:52.962Z</updated>
  <id>http://cotcloud.cn/</id>
  
  <author>
    <name>GroveTind</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈mysql中的binlog</title>
    <link href="http://cotcloud.cn/2019/01/15/%E6%B5%85%E8%B0%88mysql%E4%B8%AD%E7%9A%84binlog/"/>
    <id>http://cotcloud.cn/2019/01/15/浅谈mysql中的binlog/</id>
    <published>2019-01-15T06:47:06.000Z</published>
    <updated>2019-01-15T08:36:52.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅谈mysql中的binlog"><a href="#浅谈mysql中的binlog" class="headerlink" title="浅谈mysql中的binlog"></a>浅谈mysql中的binlog</h2><h3 id="binlog是什么？"><a href="#binlog是什么？" class="headerlink" title="binlog是什么？"></a>binlog是什么？</h3><p>binlog是mysql中的二进制日志，可以说是mysql中最重要的日志。它记录了几乎所有的DDL和DML语句（除了select查询语句），以事件形式记录，还包含语句执行所消耗的时间。mysql的二进制日志是事务安全型的。</p><ol><li>DDL即数据库定义语言。主要命令有create，alter，drop等，DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上。</li><li>DML即数据库操纵语言。主要命令有select，update，delete，insert等，主要是进行表数据的操作工作。</li></ol><h3 id="binlog有什么作用？"><a href="#binlog有什么作用？" class="headerlink" title="binlog有什么作用？"></a>binlog有什么作用？</h3><p>最常用的就是两个作用：一是mysql的主从复制，将主库的binlog日志传递到从库来更新数据从而实现主从复制；二是mysql的数据恢复。<br><a id="more"></a></p><h3 id="如何使用binlog？"><a href="#如何使用binlog？" class="headerlink" title="如何使用binlog？"></a>如何使用binlog？</h3><h4 id="binlog日志包括两类文件："><a href="#binlog日志包括两类文件：" class="headerlink" title="binlog日志包括两类文件："></a>binlog日志包括两类文件：</h4><ol><li>二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件。</li><li>二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML（除select）语句事件。</li></ol><h4 id="开启binlog日志功能"><a href="#开启binlog日志功能" class="headerlink" title="开启binlog日志功能"></a>开启binlog日志功能</h4><ol><li>编辑打开mysql配置文件etc/mys.cnf</li><li>在[mysqld]区块添加<code>log-bin=mysql-bin</code>，确认是打开状态</li><li>重启mysql服务使配置生效</li><li>查看binlog是否开启，使用<code>show variables like &#39;log_%&#39;;</code>，打开状态时结果集中会出现log_bin = ON。</li></ol><h4 id="常用的binlog日志操作命令"><a href="#常用的binlog日志操作命令" class="headerlink" title="常用的binlog日志操作命令"></a>常用的binlog日志操作命令</h4><ol><li>查看所有binlog日志列表，命令：<code>show master logs;</code></li><li>查看Master状态，即最新一个binlog日志的编号名称，以及最后一个操作事件pos结束点值，，命令：<code>show master status;</code></li><li>flush刷新log日志，自此刻开始产生一个新编号的binlog日志文件，命令：<code>flush logs;</code>。另外，当mysql服务重启时会自动触发这个命令，还有mysql dump备份数据的时候带上了参数-F也会触发。</li><li>清空所有binlog日志，命令：<code>reset master;</code></li></ol><h4 id="如何查看binlog日志"><a href="#如何查看binlog日志" class="headerlink" title="如何查看binlog日志"></a>如何查看binlog日志</h4><ol><li>使用mysqlbinlog自带命令查看，例如<code>mysqlbinlog mysql-bin.000002</code>，使用cat,more,vim等命令是无法查看二进制日志文件的。</li><li>上述方法将整个binlog日志文件内容读出，内容过多极不容易查看。可以使用<code>show binlog events[IN &#39;log_name&#39;][from pos][LIMIT [offset,] row_count];</code><br> IN ‘log_name’：指定要查询的binlog文件名（不指定就是从第一个binlog文件）<br> from pos：指定从哪个pos起始点查起（不指定就是从整个文件的第一个pos点起）<br> LIMIT [offset,]：偏移量（不指定则为0）<br> row_count：查询总条数（不指定就是所有行）</li></ol><h4 id="利用binlog日志恢复mysql数据"><a href="#利用binlog日志恢复mysql数据" class="headerlink" title="利用binlog日志恢复mysql数据"></a>利用binlog日志恢复mysql数据</h4><p>世上没有后悔药，即使有也肯定不好吃！所以恢复mysql的数据，就是在你开启了mysql的binlog日志功能后，通过阅读binlog日志文件的内容（重新去执行特定区间段的SQL语句）去挽回你的错误。<br>温馨提醒：恢复数据之前必须将binlog移出，否则恢复过程中会继续写入语句到binlog中，容易造成混乱。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浅谈mysql中的binlog&quot;&gt;&lt;a href=&quot;#浅谈mysql中的binlog&quot; class=&quot;headerlink&quot; title=&quot;浅谈mysql中的binlog&quot;&gt;&lt;/a&gt;浅谈mysql中的binlog&lt;/h2&gt;&lt;h3 id=&quot;binlog是什么？&quot;&gt;&lt;a href=&quot;#binlog是什么？&quot; class=&quot;headerlink&quot; title=&quot;binlog是什么？&quot;&gt;&lt;/a&gt;binlog是什么？&lt;/h3&gt;&lt;p&gt;binlog是mysql中的二进制日志，可以说是mysql中最重要的日志。它记录了几乎所有的DDL和DML语句（除了select查询语句），以事件形式记录，还包含语句执行所消耗的时间。mysql的二进制日志是事务安全型的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DDL即数据库定义语言。主要命令有create，alter，drop等，DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上。&lt;/li&gt;
&lt;li&gt;DML即数据库操纵语言。主要命令有select，update，delete，insert等，主要是进行表数据的操作工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;binlog有什么作用？&quot;&gt;&lt;a href=&quot;#binlog有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;binlog有什么作用？&quot;&gt;&lt;/a&gt;binlog有什么作用？&lt;/h3&gt;&lt;p&gt;最常用的就是两个作用：一是mysql的主从复制，将主库的binlog日志传递到从库来更新数据从而实现主从复制；二是mysql的数据恢复。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://cotcloud.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://cotcloud.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅谈grpc</title>
    <link href="http://cotcloud.cn/2018/12/29/%E6%B5%85%E8%B0%88grpc/"/>
    <id>http://cotcloud.cn/2018/12/29/浅谈grpc/</id>
    <published>2018-12-29T03:50:50.000Z</published>
    <updated>2018-12-29T06:57:55.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈grpc"><a href="#浅谈grpc" class="headerlink" title="浅谈grpc"></a>浅谈grpc</h1><h2 id="grpc的实现流程"><a href="#grpc的实现流程" class="headerlink" title="grpc的实现流程"></a>grpc的实现流程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1.简介：rpc即远程过程调用，简单来说就是两个进程间的通讯。grpc就是实现rpc的一个框架，但是摊上了一个好爹–google。<br>一个完整的grpc包含以下流程：<br>图文（略）<br>概括来说，grpc的流程为：</p><ol><li>通过.proto文件定义传输的接口和消息体。</li><li>通过protocol编译器生成server端和client端的stub程序。</li><li>将请求封装成HTTP2的stream。</li><li>通过channel作为数据通信通道使用socket进行数据传输。</li></ol><a id="more"></a><p>未完（留坑）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浅谈grpc&quot;&gt;&lt;a href=&quot;#浅谈grpc&quot; class=&quot;headerlink&quot; title=&quot;浅谈grpc&quot;&gt;&lt;/a&gt;浅谈grpc&lt;/h1&gt;&lt;h2 id=&quot;grpc的实现流程&quot;&gt;&lt;a href=&quot;#grpc的实现流程&quot; class=&quot;headerlink&quot; title=&quot;grpc的实现流程&quot;&gt;&lt;/a&gt;grpc的实现流程&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;1.简介：rpc即远程过程调用，简单来说就是两个进程间的通讯。grpc就是实现rpc的一个框架，但是摊上了一个好爹–google。&lt;br&gt;一个完整的grpc包含以下流程：&lt;br&gt;图文（略）&lt;br&gt;概括来说，grpc的流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过.proto文件定义传输的接口和消息体。&lt;/li&gt;
&lt;li&gt;通过protocol编译器生成server端和client端的stub程序。&lt;/li&gt;
&lt;li&gt;将请求封装成HTTP2的stream。&lt;/li&gt;
&lt;li&gt;通过channel作为数据通信通道使用socket进行数据传输。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="golang" scheme="http://cotcloud.cn/categories/golang/"/>
    
    
      <category term="grpc" scheme="http://cotcloud.cn/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>谈谈IOC/DI</title>
    <link href="http://cotcloud.cn/2018/11/06/%E8%B0%88%E8%B0%88IOC-DI/"/>
    <id>http://cotcloud.cn/2018/11/06/谈谈IOC-DI/</id>
    <published>2018-11-06T03:27:06.000Z</published>
    <updated>2018-11-12T09:53:25.702Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
      <category term="编程" scheme="http://cotcloud.cn/categories/code/"/>
    
    
      <category term="编程" scheme="http://cotcloud.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊缓存-Redis</title>
    <link href="http://cotcloud.cn/2018/11/05/%E8%81%8A%E8%81%8A%E7%BC%93%E5%AD%98-Redis/"/>
    <id>http://cotcloud.cn/2018/11/05/聊聊缓存-Redis/</id>
    <published>2018-11-05T01:23:42.000Z</published>
    <updated>2018-11-21T02:46:46.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式缓存Redis"><a href="#分布式缓存Redis" class="headerlink" title="分布式缓存Redis"></a>分布式缓存Redis</h1><h2 id="为什么使用Redis？"><a href="#为什么使用Redis？" class="headerlink" title="为什么使用Redis？"></a>为什么使用Redis？</h2><p>使用Redis主要是考虑项目的性能和并发。从性能上来说：当我们执行一个繁琐但是不经常变动的SQL时，重复的浪费时间在执行SQL上了，此时加上缓存就可以直接访问缓存，大大节约了访问数据库的时间。从并发性上说：当很多个连接去访问数据库，数据库很容易出现异常等问题。<br>当然还有Redis具有分布式锁等等优点。</p><h2 id="单线程的Redis为什么这么快？"><a href="#单线程的Redis为什么这么快？" class="headerlink" title="单线程的Redis为什么这么快？"></a>单线程的Redis为什么这么快？</h2><p>首先，Redis是常驻内存进程，纯内存操作，你说能不快吗。<br>第二，Redis是单线程操作，避免频繁的上下文切换。<br>第三，Redis采用非阻塞I/O多路复用机制，可百度详细介绍，作深入了解←_←</p><h2 id="Redis的数据类型及常用场景"><a href="#Redis的数据类型及常用场景" class="headerlink" title="Redis的数据类型及常用场景"></a>Redis的数据类型及常用场景</h2><ol><li>String。最常规的set/get操作，可存储value可以是string也可以是数字。一般做一些复杂的计数功能的缓存。</li><li>Hash。特别适合用于存储对象。有些单点登录的实现，就是借助Redis的Hash缓存cookID和对应的用户信息。</li><li>List。字符串列表，按照插入顺序排序。这种数据类型可以做一些简单的队列，也可以利用lrange实现redis的分页功能。</li><li>Set。因为set堆放的是一些不可重复值的集合。可以做去重的作用。</li><li>Sorted Set。相对于Set，多了一个权重参数sorce。可以根据sorce进行排序，例如排行榜等。</li></ol><a id="more"></a><h2 id="Redis的过期策略和内存淘汰机制"><a href="#Redis的过期策略和内存淘汰机制" class="headerlink" title="Redis的过期策略和内存淘汰机制"></a>Redis的过期策略和内存淘汰机制</h2><p>我们已经知道Redis是在内存中工作的，如果一直不停的往Redis写数据，那内存很快就不够用了，所以需要进行删除。<br>一般来说，删除策略有三种：<strong>立即删除</strong>，<strong>惰性删除</strong>，<strong>定时删除</strong>。<br><strong>立即删除：</strong>键值一过期就进行删除，保证了缓存最大的鲜活度，<strong>但是对CPU却不友好</strong>。删除是需要CPU时间的，如果CPU在高峰期，此时还要进行删除操作，无疑添加了CPU的负荷。<br><strong>惰性删除：</strong>到了过期时间不会立即删除，而是下次使用到了进行删除，显而易见，这种方式<strong>浪费了内存空间</strong>。<br><strong>定时删除：</strong>这是一种折中于上面两者之间的策略。每隔一段时间进行删除操作，并通过限制删除操作的时长和频率来减少对CPU的影响。<br><strong>而Redis采用定时删除+惰性删除。</strong>使用这种删除策略就一定没有问题吗，很明显不是的。如果定时删除没有删除key，你也长时间没有访问该key，那么还是白白浪费了内存空间。这时就要提到内存淘汰机制。<br>在redis.conf配置文件中有这么一行配置：<br><code># maxmemory-policy volatile-lru</code><br>该配置就是用来配置内存淘汰机制的。</p><ol><li><strong>noeviction：</strong>当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</li><li><strong>allkeys-lru：</strong>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。</li><li><strong>allkeys-random：</strong>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。</li><li><strong>volatile-lru：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。</li><li><strong>volatile-random：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。</li><li><strong>volatile-ttl：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。</li></ol><p><strong>注意：</strong>如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。</p><h2 id="Redis会有那些缺点？"><a href="#Redis会有那些缺点？" class="headerlink" title="Redis会有那些缺点？"></a>Redis会有那些缺点？</h2><p>任何事物都不可能是完美的，使用Redis也会出现一些问题。比如下面这些：</p><ol><li>缓存和数据库双写一致性问题。</li><li>缓存穿透问题。</li><li>缓存雪崩问题。</li><li>缓存的并发竞争问题。</li></ol><p>有问题我们就需要解决。</p><h3 id="缓存和数据库双写一致性问题"><a href="#缓存和数据库双写一致性问题" class="headerlink" title="缓存和数据库双写一致性问题"></a>缓存和数据库双写一致性问题</h3><p>一致性问题是分布式最常见的问题。一致性又可细分为最终一致性和强一致性。<br>对于强一致性的数据，是不建议放缓存的，我们做的一切只能保证最终一致性。<br>所以我们只能做好更新策略，先更新数据库，再删除缓存。对于缓存删除失败可以使用消息队列来做补偿措施。</p><h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><p>当有黑客故意发出大量请求缓存中不存在的数据时，就会发生缓存穿透，导致大量请求怼到数据库，造成数据库异常。<br>对应的解决方案：</p><ul><li><strong>利用互斥锁</strong>：缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</li><li><strong>采用异步更新策略，无论 Key 是否取到值，都直接返回。</strong></li><li><strong>提供一个能迅速判断请求是否有效的拦截机制</strong>：常用的如布隆过滤器，虽然不能保证百分百的过滤，但是很适合作为第一道门槛。</li></ul><h3 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h3><p>当有一大片缓存同时失效，而同时又来了一堆请求，就会出现大量请求直接访问到数据库，操作数据库异常。<br>对应的解决方案：</p><ul><li><strong>给缓存的失效时间，加上一个随机值，避免集体失效。</strong></li><li>使用互斥锁，很明显这种容易造成吞吐量下降。</li><li><strong>双缓存</strong>。</li></ul><h3 id="缓存的并发竞争问题"><a href="#缓存的并发竞争问题" class="headerlink" title="缓存的并发竞争问题"></a>缓存的并发竞争问题</h3><p>这种情况类似于有多个子系统要set同一个key。<br>百度很多说是利用redis事务机制来解决，单机可能有用，但是在redis集群中，数据做了分片就显得十分麻烦。<br>对于无顺序要求的，使用分布式锁，抢到锁就进行set，这种比较简单。<br>对于有顺序的，一种抢到锁进行set操作同时加上时间戳，如A要set这个key的value为a，B要set value为b，C要set value为c，在写入数据库的时候我们带上一个时间戳<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统A key（value a 11:00）</span><br><span class="line">系统B key（value b 11:01）</span><br><span class="line">系统C key（value c 11:02）</span><br></pre></td></tr></table></figure></p><p>假如B先抢到锁，执行完set操作，此时A抢到锁，发现自己的时间戳早于此时B已经写入的时间戳，那么不进行set操作。<br>还有一种就是利用队列的串行实现顺序操作。<br>还是那句话，技术是服务于实际业务的，多从实际业务中总结经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式缓存Redis&quot;&gt;&lt;a href=&quot;#分布式缓存Redis&quot; class=&quot;headerlink&quot; title=&quot;分布式缓存Redis&quot;&gt;&lt;/a&gt;分布式缓存Redis&lt;/h1&gt;&lt;h2 id=&quot;为什么使用Redis？&quot;&gt;&lt;a href=&quot;#为什么使用Redis？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用Redis？&quot;&gt;&lt;/a&gt;为什么使用Redis？&lt;/h2&gt;&lt;p&gt;使用Redis主要是考虑项目的性能和并发。从性能上来说：当我们执行一个繁琐但是不经常变动的SQL时，重复的浪费时间在执行SQL上了，此时加上缓存就可以直接访问缓存，大大节约了访问数据库的时间。从并发性上说：当很多个连接去访问数据库，数据库很容易出现异常等问题。&lt;br&gt;当然还有Redis具有分布式锁等等优点。&lt;/p&gt;
&lt;h2 id=&quot;单线程的Redis为什么这么快？&quot;&gt;&lt;a href=&quot;#单线程的Redis为什么这么快？&quot; class=&quot;headerlink&quot; title=&quot;单线程的Redis为什么这么快？&quot;&gt;&lt;/a&gt;单线程的Redis为什么这么快？&lt;/h2&gt;&lt;p&gt;首先，Redis是常驻内存进程，纯内存操作，你说能不快吗。&lt;br&gt;第二，Redis是单线程操作，避免频繁的上下文切换。&lt;br&gt;第三，Redis采用非阻塞I/O多路复用机制，可百度详细介绍，作深入了解←_←&lt;/p&gt;
&lt;h2 id=&quot;Redis的数据类型及常用场景&quot;&gt;&lt;a href=&quot;#Redis的数据类型及常用场景&quot; class=&quot;headerlink&quot; title=&quot;Redis的数据类型及常用场景&quot;&gt;&lt;/a&gt;Redis的数据类型及常用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;String。最常规的set/get操作，可存储value可以是string也可以是数字。一般做一些复杂的计数功能的缓存。&lt;/li&gt;
&lt;li&gt;Hash。特别适合用于存储对象。有些单点登录的实现，就是借助Redis的Hash缓存cookID和对应的用户信息。&lt;/li&gt;
&lt;li&gt;List。字符串列表，按照插入顺序排序。这种数据类型可以做一些简单的队列，也可以利用lrange实现redis的分页功能。&lt;/li&gt;
&lt;li&gt;Set。因为set堆放的是一些不可重复值的集合。可以做去重的作用。&lt;/li&gt;
&lt;li&gt;Sorted Set。相对于Set，多了一个权重参数sorce。可以根据sorce进行排序，例如排行榜等。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://cotcloud.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://cotcloud.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令学习之vi</title>
    <link href="http://cotcloud.cn/2018/11/02/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bvi/"/>
    <id>http://cotcloud.cn/2018/11/02/Linux命令之vi/</id>
    <published>2018-11-02T08:32:12.000Z</published>
    <updated>2018-11-02T10:10:25.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux命令学习之vi"><a href="#Linux命令学习之vi" class="headerlink" title="Linux命令学习之vi"></a>Linux命令学习之vi</h1><h2 id="一、vi的基本操作"><a href="#一、vi的基本操作" class="headerlink" title="一、vi的基本操作"></a>一、vi的基本操作</h2><ol><li>进入vi。在系统提示符号后输入<code>$vi filename</code>，就进入了vi编辑画面。需要注意得是，一进来是命令行模式。</li><li>切换到插入模式进行插入文字的操作。在命令行模式按下“i”就切换到插入模式了。需要注意的是，当你前面输错字了是不能直接删除的，这时需要切换回命令行模式删除。</li><li>插入模式切换回命令行模式。在插入模式下按“esc”就可以切换回命令行模式了。</li><li>退出vi并保存文件。在命令行模式下输入:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:w filename //将文件以filename为文件名保存，并退出vi</span><br><span class="line">:wq  //将文件保存并退出vi</span><br><span class="line">:q!  //强制退出vi，不会保存任何修改的内容</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、命令行模式功能键"><a href="#二、命令行模式功能键" class="headerlink" title="二、命令行模式功能键"></a>二、命令行模式功能键</h2><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>按“i”切换进入插入模式，此时是从光标所在位置开始插入数据；<br>按“a”切换进入插入模式，是从光标所在位置的下一个位置开始插入数据；<br>按“o”切换进入插入模式，是插入新的一行，从行首开始插入数据。</p><h3 id="从插入模式切换到命令行模式"><a href="#从插入模式切换到命令行模式" class="headerlink" title="从插入模式切换到命令行模式"></a>从插入模式切换到命令行模式</h3><p>按“esc”从插入模式切换到命令行模式。<br><a id="more"></a></p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一般都是可以直接通过上下左右键移动光标，正规的也有通过“h,j,k,l”来移动光标“左，下，上，右”。</span><br><span class="line">按“Ctrl”+“b”：屏幕往“后”移动一页。</span><br><span class="line">按“Ctrl”+“f”：屏幕往“前”移动一页。</span><br><span class="line">按“Ctrl”+“u”：屏幕往“后”移动半页。</span><br><span class="line">按“Ctrl”+“d”：屏幕往“前”移动半页。</span><br><span class="line">按数字“0”：光标移动到文件开头。</span><br><span class="line">按“g”：光标移动到文件末尾。</span><br><span class="line">按“$”：光标移动到行尾。</span><br><span class="line">按“^”：光标移动到行头。</span><br><span class="line">按“w”：光标移动到下个字的字头。</span><br><span class="line">按“e”：光标移动到下个字的字尾。</span><br><span class="line">按“b”：光标回到上个字的字头。</span><br><span class="line">按“数字”+“l”：光标移动到当前行的第几个位置。如“33l”。</span><br></pre></td></tr></table></figure><h3 id="删除文字"><a href="#删除文字" class="headerlink" title="删除文字"></a>删除文字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">按“x”：删除光标所在位置的后面的文字，类似“DEL”键删除文字。注意小写是删除后面的！</span><br><span class="line">按“数字”+“x”：删除光标所在位置后的“数字”个文字。</span><br><span class="line">按“X”：删除光标所在位置的前面的文字，类似“backspace”键删除文字。注意大写是删除前面的！</span><br><span class="line">按“数字”+“X”：删除光标所在位置前的“数字”个文字。</span><br><span class="line">按“dd”：删除光标所在行。</span><br><span class="line">按“数字”+“dd”：从光标所在行开始删除“数字”行。</span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">按“yw”：将光标所在之处到字尾的文字复制到缓冲区。</span><br><span class="line">按“数字”+“yw”：复制N个数字到缓冲区。</span><br><span class="line">按“yy”：复制光标所在行到缓冲区。</span><br><span class="line">按“数字”+“yy”：从光标所在行开始往下数N行复制到缓冲区。</span><br><span class="line">按“p”：将缓冲区的内容复制到光标所在位置。</span><br><span class="line">//通常都是y和p配合完成复制粘贴</span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按“r”：替换光标所**在**之处的字符。</span><br><span class="line">按“R”：替换光标所**到**之处的字符，直到按下“esc”键为止。</span><br></pre></td></tr></table></figure><h3 id="撤销一次命令"><a href="#撤销一次命令" class="headerlink" title="撤销一次命令"></a>撤销一次命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按“u”：可撤销一次命令，按多次可撤销多次命令。</span><br></pre></td></tr></table></figure><h3 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按“cw”：更改光标所在处的字到字尾处。</span><br><span class="line">按“c数字w”：表示更改从光标所在处开始的N个字到字尾处。</span><br></pre></td></tr></table></figure><h3 id="跳到指定的行"><a href="#跳到指定的行" class="headerlink" title="跳到指定的行"></a>跳到指定的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按“Ctrl”+“g”：显示出光标所在行的行号。</span><br><span class="line">按“数字”+“G”：跳到文件的第N行行首。</span><br></pre></td></tr></table></figure><h2 id="：模式（Last-line-mode）下功能键"><a href="#：模式（Last-line-mode）下功能键" class="headerlink" title="：模式（Last line mode）下功能键"></a>：模式（Last line mode）下功能键</h2><p>首先确定你在命令行模式下，按“:”进入last line mode该模式下。也可以理解为以下命令前都加上一个冒号，然后回车来实现相应操作，特别说明下面的只写了冒号后面的命令名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接“<span class="built_in">set</span> nu”：会显示文件中所有行的行号。</span><br><span class="line">接“数字”：会跳到文章的第N行。</span><br><span class="line">接“/”+“关键字”：会进行查找文件中的“关键字”，类似Ctrl+F搜索文字功能。按“n”寻找下一个。</span><br><span class="line">接“?”+“关键字”：一样查找关键字，但是再按“n”是向上寻找关键字。</span><br><span class="line">接“w”：保存文件。</span><br><span class="line">接“q”：退出vi。如果无法退出，可q后再接“!”强制退出。</span><br><span class="line">接“wq”：保存文件并退出vi。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux命令学习之vi&quot;&gt;&lt;a href=&quot;#Linux命令学习之vi&quot; class=&quot;headerlink&quot; title=&quot;Linux命令学习之vi&quot;&gt;&lt;/a&gt;Linux命令学习之vi&lt;/h1&gt;&lt;h2 id=&quot;一、vi的基本操作&quot;&gt;&lt;a href=&quot;#一、vi的基本操作&quot; class=&quot;headerlink&quot; title=&quot;一、vi的基本操作&quot;&gt;&lt;/a&gt;一、vi的基本操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;进入vi。在系统提示符号后输入&lt;code&gt;$vi filename&lt;/code&gt;，就进入了vi编辑画面。需要注意得是，一进来是命令行模式。&lt;/li&gt;
&lt;li&gt;切换到插入模式进行插入文字的操作。在命令行模式按下“i”就切换到插入模式了。需要注意的是，当你前面输错字了是不能直接删除的，这时需要切换回命令行模式删除。&lt;/li&gt;
&lt;li&gt;插入模式切换回命令行模式。在插入模式下按“esc”就可以切换回命令行模式了。&lt;/li&gt;
&lt;li&gt;退出vi并保存文件。在命令行模式下输入:&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:w filename //将文件以filename为文件名保存，并退出vi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;:wq  //将文件保存并退出vi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;:q!  //强制退出vi，不会保存任何修改的内容&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;二、命令行模式功能键&quot;&gt;&lt;a href=&quot;#二、命令行模式功能键&quot; class=&quot;headerlink&quot; title=&quot;二、命令行模式功能键&quot;&gt;&lt;/a&gt;二、命令行模式功能键&lt;/h2&gt;&lt;h3 id=&quot;插入模式&quot;&gt;&lt;a href=&quot;#插入模式&quot; class=&quot;headerlink&quot; title=&quot;插入模式&quot;&gt;&lt;/a&gt;插入模式&lt;/h3&gt;&lt;p&gt;按“i”切换进入插入模式，此时是从光标所在位置开始插入数据；&lt;br&gt;按“a”切换进入插入模式，是从光标所在位置的下一个位置开始插入数据；&lt;br&gt;按“o”切换进入插入模式，是插入新的一行，从行首开始插入数据。&lt;/p&gt;
&lt;h3 id=&quot;从插入模式切换到命令行模式&quot;&gt;&lt;a href=&quot;#从插入模式切换到命令行模式&quot; class=&quot;headerlink&quot; title=&quot;从插入模式切换到命令行模式&quot;&gt;&lt;/a&gt;从插入模式切换到命令行模式&lt;/h3&gt;&lt;p&gt;按“esc”从插入模式切换到命令行模式。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://cotcloud.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://cotcloud.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浏览一个页面发生的事</title>
    <link href="http://cotcloud.cn/2018/10/31/%E8%B6%A3%E8%B0%88%E6%B5%8F%E8%A7%88%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B/"/>
    <id>http://cotcloud.cn/2018/10/31/趣谈浏览一个页面发生的事/</id>
    <published>2018-10-31T06:35:26.000Z</published>
    <updated>2018-11-01T02:48:59.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在浏览器出入URL到显示页面的过程"><a href="#在浏览器出入URL到显示页面的过程" class="headerlink" title="在浏览器出入URL到显示页面的过程"></a>在浏览器出入URL到显示页面的过程</h2><p>先看下面一张图：<br><img src="/2018/10/31/趣谈浏览一个页面发生的事/1.png" alt="图解页面显示过程" title="图解页面显示过程"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 当用户在浏览器输入一个URL后，浏览器会利用DNS协议查找域名对应的ip，这时找到了要连接的服务器；</span><br><span class="line">2. 然后浏览器通过http协议生成一个http请求报文，并向web服务器发送这个http请求报文，期间通过tcp协议与服务器建立连接；</span><br><span class="line">3. 与服务器建立连接后，在网络层通过ip协议发送数据，ip数据包在路由之间使用OPSF协议进行路由选择，路由器在于服务器通信时，需要使用ARP协议将ip地址转成MAC地址；</span><br><span class="line">4. 服务器通过TCP协议接收到请求和通过http协议处理请求，同样通过http协议生成要返回的HTML页面和使用TCP协议返回页面内容。</span><br><span class="line">5. 浏览器接收到页面内容，渲染页面。</span><br></pre></td></tr></table></figure></p><p>这张图也简单解释了各个协议与HTTP协议的关系。<br><a id="more"></a></p><h2 id="OSI七层体系和TCP-IP体系"><a href="#OSI七层体系和TCP-IP体系" class="headerlink" title="OSI七层体系和TCP/IP体系"></a>OSI七层体系和TCP/IP体系</h2><ul><li>OSI七层体系<ol><li>应用层</li><li>表示层</li><li>会话层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ol></li><li>TCP/IP体系<ol><li>应用层（对应OSI中的上三层：应用层、表示层、会话层；各种应用层协议如http,smtp,ftp,telnet协议等）</li><li>运输层（TCP，UDP协议）</li><li>网络层（IP层）</li><li>网络接口层（对应OSI中的最下面两层：数据链路层、物理层）</li></ol></li><li>五层体系<ol><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层   </li></ol></li></ul><p>相对于OSI和TCP/IP体系，提出的一种折中的描述。其实就是将TCP/IP体系的网络接口层还原成数据链路层和物理层了，这样结合两种体系的描述相对更好理解。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1XX：信息性状态码。如：接收的请求正在处理。</span><br><span class="line">2XX：成功状态码。如：请求成功处理。</span><br><span class="line">3XX：重定向状态码。如：需要附加操作以完成请求。</span><br><span class="line">4XX：客户端错误码。如：服务器无法进行操作。</span><br><span class="line">5XX：服务器错误码。如：服务器处理请求出错。</span><br></pre></td></tr></table></figure><h2 id="HTTP中的长连接和短连接"><a href="#HTTP中的长连接和短连接" class="headerlink" title="HTTP中的长连接和短连接"></a>HTTP中的长连接和短连接</h2><p>在HTTP/1.0中默认使用短连接，即客户端和服务器每进行一次http操作，就建立一次连接，任务结束就断开连接。如果客户端请求的HTML中包含其他web资源（如js文件，css文件，图片等），每有一个其他的web资源都会新建一个http会话。<br>而从HTTP/1.1起，默认使用长连接。使用长连接的HTTP协议，会在响应头中加入这行代码<code>Connection:keep-alive</code><br>keep-alive也不是永久保持连接的，这个保持时间是在服务器（如apache）中进行设置的，同时长连接需要客户端和服务器都支持。<br><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong><br><a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener"><strong>**具体关于长短连接的介绍可点击这里**</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在浏览器出入URL到显示页面的过程&quot;&gt;&lt;a href=&quot;#在浏览器出入URL到显示页面的过程&quot; class=&quot;headerlink&quot; title=&quot;在浏览器出入URL到显示页面的过程&quot;&gt;&lt;/a&gt;在浏览器出入URL到显示页面的过程&lt;/h2&gt;&lt;p&gt;先看下面一张图：&lt;br&gt;&lt;img src=&quot;/2018/10/31/趣谈浏览一个页面发生的事/1.png&quot; alt=&quot;图解页面显示过程&quot; title=&quot;图解页面显示过程&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 当用户在浏览器输入一个URL后，浏览器会利用DNS协议查找域名对应的ip，这时找到了要连接的服务器；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 然后浏览器通过http协议生成一个http请求报文，并向web服务器发送这个http请求报文，期间通过tcp协议与服务器建立连接；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 与服务器建立连接后，在网络层通过ip协议发送数据，ip数据包在路由之间使用OPSF协议进行路由选择，路由器在于服务器通信时，需要使用ARP协议将ip地址转成MAC地址；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 服务器通过TCP协议接收到请求和通过http协议处理请求，同样通过http协议生成要返回的HTML页面和使用TCP协议返回页面内容。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. 浏览器接收到页面内容，渲染页面。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这张图也简单解释了各个协议与HTTP协议的关系。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://cotcloud.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://cotcloud.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>网络间进程通讯之socket</title>
    <link href="http://cotcloud.cn/2018/10/30/%E4%BA%86%E8%A7%A3socket/"/>
    <id>http://cotcloud.cn/2018/10/30/了解socket/</id>
    <published>2018-10-30T06:32:18.000Z</published>
    <updated>2018-10-31T01:15:01.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket通讯原理"><a href="#socket通讯原理" class="headerlink" title="socket通讯原理"></a>socket通讯原理</h1><h2 id="网络间进程如何进行通讯"><a href="#网络间进程如何进行通讯" class="headerlink" title="网络间进程如何进行通讯"></a>网络间进程如何进行通讯</h2><p>本地的进程间通讯我们知道有很多种实现方式，可以总结为这四类：消息传递（管道，FIFO，消息队列），同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量），共享内存，远程过程调用。<br>那么网络间进程通讯如何实现呢？<br>解决这个问题，我们首先要思考如何唯一标识网络间的进程。在本地进程间，可以通过PID来唯一标识，但在网络间这明显是行不通。其实tcp/ip协议簇已经帮我们解决了这个问题，通过网络层的ip协议帮助我们确定网络间的唯一主机，而传输层的“协议+端口”可以确定主机中唯一的应用程序（进程）。这样利用（ip，协议，端口）三元数组就能唯一标识网络间的进程了。<br>使用tcp/ip协议簇的应用程序通常都采用应用编程接口（socket和TLI）来进行通讯。而TLI这种似乎已经被淘汰了，现在基本都是使用的socket实现通讯。</p><h2 id="什么是socket？"><a href="#什么是socket？" class="headerlink" title="什么是socket？"></a>什么是socket？</h2><p>socket一词源于UNIX，而UNIX的哲学理论就是“一切皆是文件，都可以通过open、write、read、close模式来操作”。所以socket其实就是一个“文件”。<br>也是通过一些实现open，write，read，close操作的函数使用socket。</p><h2 id="常用的操作socket的函数"><a href="#常用的操作socket的函数" class="headerlink" title="常用的操作socket的函数"></a>常用的操作socket的函数</h2><h3 id="socket-int-domain-int-type-int-protocol"><a href="#socket-int-domain-int-type-int-protocol" class="headerlink" title="socket(int domain, int type, int protocol)"></a>socket(int domain, int type, int protocol)</h3><p>socket()函数，对应于常用的打开文件的函数。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。<br>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。正如fopen()函数一样，socket()函数也需要传入一定的参数来创建特定的socket描述符。</p><pre><code>1. domain参数指定socket的协议簇，协议簇决定了socket的地址类型。例如AF_INET决定了要用Ipv4地址(32位的)和端口号(16位的)组合的地址类型。还有诸如AF_INET6、AF_LOCAL等就不细说了。2. type参数指定socket的类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。3. protocol参数顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等。   </code></pre><p>其中type和protocol不是随意进行组合的。<br>当我们调用socket()函数创建一个socket描述符时，返回的描述符是存在于协议簇中的，没有一个具体的地址。如果想要给描述符赋值一个地址，我们必须调用bind()函数，否则我们调用listen(),connect()函数时，系统会随机分配一个端口。</p><a id="more"></a><h3 id="bind-int-sockfd-addr-addrLen"><a href="#bind-int-sockfd-addr-addrLen" class="headerlink" title="bind(int sockfd, _ *addr, _ *addrLen)"></a>bind(int sockfd, _ *addr, _ *addrLen)</h3><p>bind()函数,上面我们说到，通过socket()函数创建的socket是没有具体地址的，而我们想要给它赋值一个地址就需要调用bind()函数。</p><pre><code>1. sockfd参数，socket描述符。通过socket()函数创建的socket描述符。2. addr参数，给socket描述符绑定的协议地址。这个协议地址跟调用socket()函数传入的协议簇是对应相关的。3. addrLen参数，协议地址长度。   </code></pre><p>通常服务器在启动时都会绑定一个协议地址（ip+端口），以便提供服务，客户端通过连接这个协议地址来连接服务器；而客户端则不用，由系统随机产生一个端口号和自身ip组合。</p><h3 id="listen-int-sockfd-int-backlog"><a href="#listen-int-sockfd-int-backlog" class="headerlink" title="listen(int sockfd, int backlog)"></a>listen(int sockfd, int backlog)</h3><p>listen()函数。通常socket()函数创建的socket是主动类型的，通过listen()函数将socket变成被动类型，等待客户端来连接。</p><pre><code>1. sockfd参数，被监听的socket描述符。2. backlog参数，被监听的socket可以排队的最大连接个数。   </code></pre><p>通常作为一个服务器，在调用完socket()，bind()函数后，就会调用listen()来监听socket，如果有客户端调用connect()函数发出连接请求，服务器就会接受到这个请求。</p><h3 id="connect-int-sockfd-addrSrv-int-addrLen"><a href="#connect-int-sockfd-addrSrv-int-addrLen" class="headerlink" title="connect(int sockfd, _ *addrSrv, int addrLen)"></a>connect(int sockfd, _ *addrSrv, int addrLen)</h3><p>connect()函数。客户端调用该函数向服务器发出连接请求，等待服务器响应。</p><pre><code>1. sockfd参数，客户端的socket描述符。2. addrSrv参数，服务器的socket地址。3. addrLen参数，socket地址的长度。   </code></pre><h3 id="accept-int-sockfd-addr-addrLen"><a href="#accept-int-sockfd-addr-addrLen" class="headerlink" title="accept(int sockfd, _ *addr, _ *addrLen)"></a>accept(int sockfd, _ *addr, _ *addrLen)</h3><p>accept()函数。当服务器调用socket(),bind(),listen()函数后就会监听生成的socket地址,客户端调用socket(),connect()函数后就会向服务器发出连接请求，服务器监听到这个连接请求后，就会调用accept()函数去接收客户端的连接请求。<br>到此服务器和客户端就连接上了，之后就是进行i/o操作。</p><pre><code>1. sockfd参数，服务器创建的socket描述符。2. addr参数，指向一个结构体类型的指针。用于返回客户端的协议地址。3. addrLen参数，协议地址的长度。   </code></pre><p>如果accept()成功，则返回一个由内核生成的新的描述符，表示与返回客户端的连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">说明：accept()函数的第一个参数是服务器调用socket()函数创建的“被监听socket描述符”；</span><br><span class="line">而accept()函数调用成功后返回的是“已连接描述符”。</span><br><span class="line">“被监听socket描述符”通常只在服务器启动时仅仅创建一个，它在该服务器的生命周期内一直存在。</span><br><span class="line">而“已连接描述符”是由内核为每一个（服务器接受了客户端的连接）连接创建的描述符，</span><br><span class="line">在服务器完成了对某个客户端的服务后，相应的“已连接描述符”就会被关闭。</span><br></pre></td></tr></table></figure></p><h3 id="read-write-等函数"><a href="#read-write-等函数" class="headerlink" title="read()/write()等函数"></a>read()/write()等函数</h3><p>read函数是负责从fd中读取内容read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p><h3 id="close-int-sockfd"><a href="#close-int-sockfd" class="headerlink" title="close(int sockfd)"></a>close(int sockfd)</h3><p>close()函数。在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><pre><code>1. sockfd参数，已连接描述符。   </code></pre><p>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><h2 id="TCP三次握手建立连接详解"><a href="#TCP三次握手建立连接详解" class="headerlink" title="TCP三次握手建立连接详解"></a>TCP三次握手建立连接详解</h2><p>我们知道TCP建立连接需要进行三次握手，即收发三组数据。大致流程为：</p><pre><code>1. 客户端向服务器发起连接，发送一个SYN j；2. 服务器响应客户端一个SYN k，并对接受的SYN j 确认ACK j+1；3. 客户端向服务器响应，并对接受的SYN k 确认ACK k+1。   </code></pre><p><img src="/2018/10/30/了解socket/1.png" alt="tcp三次握手示意图" title="tcp三次握手示意图"><br>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;socket通讯原理&quot;&gt;&lt;a href=&quot;#socket通讯原理&quot; class=&quot;headerlink&quot; title=&quot;socket通讯原理&quot;&gt;&lt;/a&gt;socket通讯原理&lt;/h1&gt;&lt;h2 id=&quot;网络间进程如何进行通讯&quot;&gt;&lt;a href=&quot;#网络间进程如何进行通讯&quot; class=&quot;headerlink&quot; title=&quot;网络间进程如何进行通讯&quot;&gt;&lt;/a&gt;网络间进程如何进行通讯&lt;/h2&gt;&lt;p&gt;本地的进程间通讯我们知道有很多种实现方式，可以总结为这四类：消息传递（管道，FIFO，消息队列），同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量），共享内存，远程过程调用。&lt;br&gt;那么网络间进程通讯如何实现呢？&lt;br&gt;解决这个问题，我们首先要思考如何唯一标识网络间的进程。在本地进程间，可以通过PID来唯一标识，但在网络间这明显是行不通。其实tcp/ip协议簇已经帮我们解决了这个问题，通过网络层的ip协议帮助我们确定网络间的唯一主机，而传输层的“协议+端口”可以确定主机中唯一的应用程序（进程）。这样利用（ip，协议，端口）三元数组就能唯一标识网络间的进程了。&lt;br&gt;使用tcp/ip协议簇的应用程序通常都采用应用编程接口（socket和TLI）来进行通讯。而TLI这种似乎已经被淘汰了，现在基本都是使用的socket实现通讯。&lt;/p&gt;
&lt;h2 id=&quot;什么是socket？&quot;&gt;&lt;a href=&quot;#什么是socket？&quot; class=&quot;headerlink&quot; title=&quot;什么是socket？&quot;&gt;&lt;/a&gt;什么是socket？&lt;/h2&gt;&lt;p&gt;socket一词源于UNIX，而UNIX的哲学理论就是“一切皆是文件，都可以通过open、write、read、close模式来操作”。所以socket其实就是一个“文件”。&lt;br&gt;也是通过一些实现open，write，read，close操作的函数使用socket。&lt;/p&gt;
&lt;h2 id=&quot;常用的操作socket的函数&quot;&gt;&lt;a href=&quot;#常用的操作socket的函数&quot; class=&quot;headerlink&quot; title=&quot;常用的操作socket的函数&quot;&gt;&lt;/a&gt;常用的操作socket的函数&lt;/h2&gt;&lt;h3 id=&quot;socket-int-domain-int-type-int-protocol&quot;&gt;&lt;a href=&quot;#socket-int-domain-int-type-int-protocol&quot; class=&quot;headerlink&quot; title=&quot;socket(int domain, int type, int protocol)&quot;&gt;&lt;/a&gt;socket(int domain, int type, int protocol)&lt;/h3&gt;&lt;p&gt;socket()函数，对应于常用的打开文件的函数。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。&lt;br&gt;这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。正如fopen()函数一样，socket()函数也需要传入一定的参数来创建特定的socket描述符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. domain参数指定socket的协议簇，协议簇决定了socket的地址类型。例如AF_INET决定了要用Ipv4地址(32位的)和端口号(16位的)组合的地址类型。还有诸如AF_INET6、AF_LOCAL等就不细说了。
2. type参数指定socket的类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。
3. protocol参数顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等。   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中type和protocol不是随意进行组合的。&lt;br&gt;当我们调用socket()函数创建一个socket描述符时，返回的描述符是存在于协议簇中的，没有一个具体的地址。如果想要给描述符赋值一个地址，我们必须调用bind()函数，否则我们调用listen(),connect()函数时，系统会随机分配一个端口。&lt;/p&gt;
    
    </summary>
    
      <category term="Socket" scheme="http://cotcloud.cn/categories/Socket/"/>
    
    
      <category term="Socket" scheme="http://cotcloud.cn/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令学习之ps</title>
    <link href="http://cotcloud.cn/2018/10/19/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E4%B9%8Bps/"/>
    <id>http://cotcloud.cn/2018/10/19/Linux命令学习之ps/</id>
    <published>2018-10-19T02:59:27.000Z</published>
    <updated>2018-10-19T03:48:10.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ps命令详解"><a href="#ps命令详解" class="headerlink" title="ps命令详解"></a>ps命令详解</h1><h2 id="Linux上进程有五种状态"><a href="#Linux上进程有五种状态" class="headerlink" title="Linux上进程有五种状态"></a>Linux上进程有五种状态</h2><ol><li>运行（正在运行或在运行队列中等待）</li><li>中断（休眠中，受阻，在等待某个条件的行程或接受到信号）</li><li>不可中断</li><li>僵死（进程已经终止，但进程描述符存在）</li><li>停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行）</li></ol><h2 id="ps工具标识进程的五种状态码"><a href="#ps工具标识进程的五种状态码" class="headerlink" title="ps工具标识进程的五种状态码"></a>ps工具标识进程的五种状态码</h2><ol><li>D：不可中断</li><li>R：运行中</li><li>S：中断</li><li>T：停止</li><li>Z：僵死  </li></ol><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>名称：ps<br>使用权限：所有使用者<br>使用方式：ps /[options/] /[–help/]<br>说明：显示瞬间进程的动态<br>参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//ps的参数较多，以下仅列出常用几个</span><br><span class="line">-A    列出所有进程</span><br><span class="line">-w    显示加宽可以显示更多的信息</span><br><span class="line">-au   显示较详细的信息</span><br><span class="line">-aux  显示所有包含其他使用者的进程信息</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>举例说明au(x)所显示的每列所指内容。-aux的输出格式:<br><code>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</code><br>每列所指内容分别为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">USER：进程拥有者</span><br><span class="line">PID：进程ID</span><br><span class="line">%CPU：占用的CPU使用率</span><br><span class="line">%MEM：占用的内存使用率</span><br><span class="line">VSZ：占用的虚拟内存大小</span><br><span class="line">RSS：占用的磁盘大小</span><br><span class="line">TTY：进程所属的终端控制台</span><br><span class="line">STAT：进程状态码（下面有详细说明）</span><br><span class="line">START：进程开始时间</span><br><span class="line">TIME：执行时间</span><br><span class="line">COMMAND：执行的命令</span><br></pre></td></tr></table></figure></p><p>其中进程状态码有以下等：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D: 不可中断的静止   </span><br><span class="line">R: 正在执行中   </span><br><span class="line">S: 静止状态   </span><br><span class="line">T: 暂停执行   </span><br><span class="line">Z: 不存在但暂时无法消除，僵死状态  </span><br><span class="line">W: 没有足够的记忆体分页可分配   </span><br><span class="line">&lt;: 高优先序的进程   </span><br><span class="line">N: 低优先序的进程   </span><br><span class="line">L: 有记忆体分页分配并锁在记忆体内</span><br></pre></td></tr></table></figure></p><p>最常用的方法是ps -aux,然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。</p><h2 id="与top的区别"><a href="#与top的区别" class="headerlink" title="与top的区别"></a>与top的区别</h2><p>ps是提供给你当前进程的快照，而top是即时显示活跃的进程。更多top相关的命令可查阅top命令的文章</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ps命令详解&quot;&gt;&lt;a href=&quot;#ps命令详解&quot; class=&quot;headerlink&quot; title=&quot;ps命令详解&quot;&gt;&lt;/a&gt;ps命令详解&lt;/h1&gt;&lt;h2 id=&quot;Linux上进程有五种状态&quot;&gt;&lt;a href=&quot;#Linux上进程有五种状态&quot; class=&quot;headerlink&quot; title=&quot;Linux上进程有五种状态&quot;&gt;&lt;/a&gt;Linux上进程有五种状态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;运行（正在运行或在运行队列中等待）&lt;/li&gt;
&lt;li&gt;中断（休眠中，受阻，在等待某个条件的行程或接受到信号）&lt;/li&gt;
&lt;li&gt;不可中断&lt;/li&gt;
&lt;li&gt;僵死（进程已经终止，但进程描述符存在）&lt;/li&gt;
&lt;li&gt;停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;ps工具标识进程的五种状态码&quot;&gt;&lt;a href=&quot;#ps工具标识进程的五种状态码&quot; class=&quot;headerlink&quot; title=&quot;ps工具标识进程的五种状态码&quot;&gt;&lt;/a&gt;ps工具标识进程的五种状态码&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;D：不可中断&lt;/li&gt;
&lt;li&gt;R：运行中&lt;/li&gt;
&lt;li&gt;S：中断&lt;/li&gt;
&lt;li&gt;T：停止&lt;/li&gt;
&lt;li&gt;Z：僵死  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;ps命令&quot;&gt;&lt;a href=&quot;#ps命令&quot; class=&quot;headerlink&quot; title=&quot;ps命令&quot;&gt;&lt;/a&gt;ps命令&lt;/h2&gt;&lt;p&gt;名称：ps&lt;br&gt;使用权限：所有使用者&lt;br&gt;使用方式：ps /[options/] /[–help/]&lt;br&gt;说明：显示瞬间进程的动态&lt;br&gt;参数：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//ps的参数较多，以下仅列出常用几个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-A    列出所有进程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-w    显示加宽可以显示更多的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-au   显示较详细的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-aux  显示所有包含其他使用者的进程信息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://cotcloud.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://cotcloud.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo引用图片</title>
    <link href="http://cotcloud.cn/2018/10/18/test-img/"/>
    <id>http://cotcloud.cn/2018/10/18/test-img/</id>
    <published>2018-10-18T09:20:28.000Z</published>
    <updated>2018-10-18T10:05:02.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo引用图片"><a href="#hexo引用图片" class="headerlink" title="hexo引用图片"></a>hexo引用图片</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p><h2 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h2><p>跟正常的Markdown引用图片一样，只是路径使用的是相对路径。在你安装插件之后，使用<code>hexo new &quot;新博客&quot;</code>生成新博客时。<br>_post文件夹下会有个跟新博客同名的文件夹，该文件夹下就是用来放置你引用的图片的。<br>在博客中你可以这样使用<code>xxxx![图片名称](文件夹名称/图片名称 &quot;图片标题&quot;)xxxx</code>，xxxx指的是你的博客内容，图片名称就是显示在图片下面的名称，图片标题就是鼠标放上去显示的文字。<br>例如我使用<code>![我是图片](test-img/1.jpg &quot;测试图片&quot;)</code>，实现效果为：<br><img src="/2018/10/18/test-img/1.jpg" alt="我是图片" title="测试图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hexo引用图片&quot;&gt;&lt;a href=&quot;#hexo引用图片&quot; class=&quot;headerlink&quot; title=&quot;hexo引用图片&quot;&gt;&lt;/a&gt;hexo引用图片&lt;/h1&gt;&lt;h2 id=&quot;安装插件&quot;&gt;&lt;a href=&quot;#安装插件&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="编程" scheme="http://cotcloud.cn/categories/code/"/>
    
    
      <category term="编程" scheme="http://cotcloud.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下修改主机名</title>
    <link href="http://cotcloud.cn/2018/10/18/Linux%E4%B8%8B%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/"/>
    <id>http://cotcloud.cn/2018/10/18/Linux下修改主机名/</id>
    <published>2018-10-18T08:07:14.000Z</published>
    <updated>2018-10-18T09:01:12.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下修改主机名"><a href="#Linux下修改主机名" class="headerlink" title="Linux下修改主机名"></a>Linux下修改主机名</h1><h2 id="hostname-主机名"><a href="#hostname-主机名" class="headerlink" title="hostname + 主机名"></a>hostname + 主机名</h2><p>这种修改只是暂时有效，在当前Linux运行期间有效。重启后就失效了。</p><h2 id="修改-etc-hosts"><a href="#修改-etc-hosts" class="headerlink" title="修改/etc/hosts"></a>修改/etc/hosts</h2><p>这种方法文件里的主机名只是用来提供给dns解析的.如果你用不上dns,只需要修改主机名,那修改这个没用。</p><h2 id="修改这个文件etc-sysconfig-network里的主机名"><a href="#修改这个文件etc-sysconfig-network里的主机名" class="headerlink" title="修改这个文件etc/sysconfig/network里的主机名"></a>修改这个文件etc/sysconfig/network里的主机名</h2><p>这种方法可以实现永久修改主机名，需要重启Linux后才能生效。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=主机名</span><br></pre></td></tr></table></figure></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li><code>#hostname 新主机名</code></li><li>修改/etc/sysconfig/network中的hostname的值</li><li>修改/etc/hosts文件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux下修改主机名&quot;&gt;&lt;a href=&quot;#Linux下修改主机名&quot; class=&quot;headerlink&quot; title=&quot;Linux下修改主机名&quot;&gt;&lt;/a&gt;Linux下修改主机名&lt;/h1&gt;&lt;h2 id=&quot;hostname-主机名&quot;&gt;&lt;a href=&quot;#hostn
      
    
    </summary>
    
      <category term="Linux" scheme="http://cotcloud.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://cotcloud.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>多电脑发布hexo博客</title>
    <link href="http://cotcloud.cn/2018/10/12/%E5%A4%9A%E7%94%B5%E8%84%91%E5%8F%91%E5%B8%83hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://cotcloud.cn/2018/10/12/多电脑发布hexo博客/</id>
    <published>2018-10-12T03:59:42.524Z</published>
    <updated>2018-10-12T08:58:51.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多电脑发布hexo博客"><a href="#多电脑发布hexo博客" class="headerlink" title="多电脑发布hexo博客"></a>多电脑发布hexo博客</h1><h2 id="准备github账号"><a href="#准备github账号" class="headerlink" title="准备github账号"></a>准备github账号</h2><p>在<a href="http://github.com" target="_blank" rel="noopener">github</a>上注册账号，并新建仓库。</p><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>按照网上的教程安装nodejs和hexo，教程很多不赘述了。</p><h2 id="github上新建分支，将部署源码提交上去"><a href="#github上新建分支，将部署源码提交上去" class="headerlink" title="github上新建分支，将部署源码提交上去"></a>github上新建分支，将部署源码提交上去</h2><p>在博客库新建分支xxx，例如笔者命名为hexo分支，将部署源码提交上去。这里需要修改.gitignore文件，将不必要提交的本地配置等文件加进去。</p><h2 id="另一台电脑安装hexo，clone部署源码"><a href="#另一台电脑安装hexo，clone部署源码" class="headerlink" title="另一台电脑安装hexo，clone部署源码"></a>另一台电脑安装hexo，clone部署源码</h2><p>另一台电脑安装和部署好hexo的环境，配置好Git，clone部署源码，就可以协同发布了。</p><p>#总结<br>现在一个电脑上提交部署源码到git上，后面就是在git上协同发布博客的操作。<br>电脑A<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"提交部署源码"</span></span><br><span class="line">git push origin hexo   //初次将部署源码提交上hexo分支</span><br></pre></td></tr></table></figure></p><p>电脑B<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull   //先更新下本地内容，再修改，再提交</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">""</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p><p>电脑A<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull   //先更新下本地内容，再修改，再提交</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">""</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多电脑发布hexo博客&quot;&gt;&lt;a href=&quot;#多电脑发布hexo博客&quot; class=&quot;headerlink&quot; title=&quot;多电脑发布hexo博客&quot;&gt;&lt;/a&gt;多电脑发布hexo博客&lt;/h1&gt;&lt;h2 id=&quot;准备github账号&quot;&gt;&lt;a href=&quot;#准备githu
      
    
    </summary>
    
      <category term="随笔" scheme="http://cotcloud.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://cotcloud.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://cotcloud.cn/2018/10/09/hello-world/"/>
    <id>http://cotcloud.cn/2018/10/09/hello-world/</id>
    <published>2018-10-09T09:11:20.821Z</published>
    <updated>2018-10-09T08:24:02.766Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a h
      
    
    </summary>
    
      <category term="hexo" scheme="http://cotcloud.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://cotcloud.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq实例</title>
    <link href="http://cotcloud.cn/2018/10/08/rabbitmq%E5%AE%9E%E4%BE%8B/"/>
    <id>http://cotcloud.cn/2018/10/08/rabbitmq实例/</id>
    <published>2018-10-08T09:12:42.000Z</published>
    <updated>2018-10-08T10:04:06.569Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="rabbitmq" scheme="http://cotcloud.cn/categories/rabbitmq/"/>
    
    
      <category term="php" scheme="http://cotcloud.cn/tags/php/"/>
    
      <category term="rabbitmq" scheme="http://cotcloud.cn/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="http://cotcloud.cn/2018/10/08/rabbitmq%E5%85%A5%E9%97%A8/"/>
    <id>http://cotcloud.cn/2018/10/08/rabbitmq入门/</id>
    <published>2018-10-08T08:20:27.000Z</published>
    <updated>2018-10-09T06:49:46.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><p>Broker：简单来说就是消息队列服务器实体。<br>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。<br>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。<br>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。<br>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。<br>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。<br>producer：消息生产者，就是投递消息的程序。<br>consumer：消息消费者，就是接受消息的程序。<br>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。<br><a id="more"></a></p><h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><p>消息队列的使用过程大概如下：<br>(1)客户端连接到消息队列服务器，打开一个channel。<br>(2)客户端声明一个exchange，并设置相关属性。<br>(3)客户端声明一个queue，并设置相关属性。<br>(4)客户端使用routing key，在exchange和queue之间建立好绑定关系。<br>(5)客户端投递消息到exchange。</p><p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。<br>exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。<br>对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”*”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*”只匹配”abc.def”。<br>还有一种不需要key的，叫做Fanout交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。</p><p>RabbitMQ支持消息的持久化，也就是数据写在磁盘上，为了数据安全考虑，我想大多数用户都会选择持久化。消息队列持久化包括3个部分：<br>(1)exchange持久化，在声明时指定durable =&gt; 1<br>(2)queue持久化，在声明时指定durable =&gt; 1<br>(3)消息持久化，在投递时指定delivery_mode =&gt; 2（1是非持久化）<br>如果exchange和queue都是持久化的，那么它们之间的binding也是持久化的。如果exchange和queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念说明&quot;&gt;&lt;a href=&quot;#概念说明&quot; class=&quot;headerlink&quot; title=&quot;概念说明&quot;&gt;&lt;/a&gt;概念说明&lt;/h2&gt;&lt;h3 id=&quot;名词介绍&quot;&gt;&lt;a href=&quot;#名词介绍&quot; class=&quot;headerlink&quot; title=&quot;名词介绍&quot;&gt;&lt;/a&gt;名词介绍&lt;/h3&gt;&lt;p&gt;Broker：简单来说就是消息队列服务器实体。&lt;br&gt;Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。&lt;br&gt;Queue：消息队列载体，每个消息都会被投入到一个或多个队列。&lt;br&gt;Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。&lt;br&gt;Routing Key：路由关键字，exchange根据这个关键字进行消息投递。&lt;br&gt;vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。&lt;br&gt;producer：消息生产者，就是投递消息的程序。&lt;br&gt;consumer：消息消费者，就是接受消息的程序。&lt;br&gt;channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="rabbitmq" scheme="http://cotcloud.cn/categories/rabbitmq/"/>
    
    
      <category term="php" scheme="http://cotcloud.cn/tags/php/"/>
    
      <category term="rabbitmq" scheme="http://cotcloud.cn/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>mysql嵌套事务的隐式提交</title>
    <link href="http://cotcloud.cn/2018/10/08/mysql%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1/"/>
    <id>http://cotcloud.cn/2018/10/08/mysql嵌套事务/</id>
    <published>2018-10-08T08:15:27.000Z</published>
    <updated>2018-10-09T07:02:51.052Z</updated>
    
    <content type="html"><![CDATA[<p>mysql官方文档是表明不支持嵌套事务的。在一个事务中开启另一个事务，会隐式commit外层事务。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>新建一个测试表（建表SQL略），表名：demo，字段：id（自增），txt。开启事务如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO demo (txt) VALUES (<span class="string">'job'</span>);</span><br><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO demo (txt) VALUES (<span class="string">'cook'</span>);</span><br><span class="line">COMMIT;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure></p><p>当你只执行前两句SQL时，此时观察表中并没有txt为job的数据。当你执行前三句你会发现表中已经有了txt为job的数据。<br><a id="more"></a></p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>还有以下一些关键词会触发mysql的隐式提交。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ALTER FUNCTION    </span><br><span class="line">ALTER PROCEDURE    </span><br><span class="line">ALTER TABLE    </span><br><span class="line">BEGIN    </span><br><span class="line">CREATE DATABASE    </span><br><span class="line">CREATE FUNCTION    </span><br><span class="line">CREATE INDEX    </span><br><span class="line">CREATE PROCEDURE    </span><br><span class="line">CREATE TABLE    </span><br><span class="line">DROP DATABASE    </span><br><span class="line">DROP FUNCTION    </span><br><span class="line">DROP INDEX    </span><br><span class="line">DROP PROCEDURE    </span><br><span class="line">DROP TABLE    </span><br><span class="line">UNLOCK TABLES    </span><br><span class="line">LOAD MASTER DATA    </span><br><span class="line">LOCK TABLES    </span><br><span class="line">RENAME TABLE    </span><br><span class="line">TRUNCATE TABLE    </span><br><span class="line">SET AUTOCOMMIT=1    </span><br><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql官方文档是表明不支持嵌套事务的。在一个事务中开启另一个事务，会隐式commit外层事务。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;新建一个测试表（建表SQL略），表名：demo，字段：id（自增），txt。开启事务如下：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;START TRANSACTION;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO demo (txt) VALUES (&lt;span class=&quot;string&quot;&gt;&#39;job&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;START TRANSACTION;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO demo (txt) VALUES (&lt;span class=&quot;string&quot;&gt;&#39;cook&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;COMMIT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ROLLBACK;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当你只执行前两句SQL时，此时观察表中并没有txt为job的数据。当你执行前三句你会发现表中已经有了txt为job的数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://cotcloud.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://cotcloud.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>IDE破解教程</title>
    <link href="http://cotcloud.cn/2018/10/08/IDE%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    <id>http://cotcloud.cn/2018/10/08/IDE破解教程/</id>
    <published>2018-10-08T07:00:00.000Z</published>
    <updated>2018-10-09T06:35:57.181Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>分享一个IDE破解教程，<a href="http://idea.lanyus.com" target="_blank" rel="noopener">我是网址</a></p><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p>win下找到hosts文件，在hosts文件中添加“0.0.0.0  account.jetbrains.com”这行内容。<br>Mac直接在终端使用vim编辑<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/hosts</span><br></pre></td></tr></table></figure></p><h3 id="复制注册码"><a href="#复制注册码" class="headerlink" title="复制注册码"></a>复制注册码</h3><p>打开<a href="http://idea.lanyus.com" target="_blank" rel="noopener">网址</a>，点击获取注册码，copy过去就OK了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;分享一个IDE破解教程，&lt;a href=&quot;http://idea.lanyus.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我是网址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改hosts文件&quot;&gt;&lt;a href=&quot;#修
      
    
    </summary>
    
      <category term="PHP" scheme="http://cotcloud.cn/categories/PHP/"/>
    
    
      <category term="php" scheme="http://cotcloud.cn/tags/php/"/>
    
      <category term="ide" scheme="http://cotcloud.cn/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>入门</title>
    <link href="http://cotcloud.cn/2018/04/20/demo/"/>
    <id>http://cotcloud.cn/2018/04/20/demo/</id>
    <published>2018-04-20T02:43:27.000Z</published>
    <updated>2018-10-09T06:36:11.831Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>This is a demo for studying to write blog by markdown, welcome to my <a href="https://github.com/servother" target="_blank" rel="noopener">github</a>!</p><h2 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h2><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1.命令"></a>1.命令</h3><h4 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章名"</span>  //创建新的博客文章</span><br></pre></td></tr></table></figure><h4 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//当你编辑完新的文章，需要下面的命令更新并发布到github上</span><br><span class="line">$ hexo clean </span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><h3 id="2-关于"><a href="#2-关于" class="headerlink" title="2.关于"></a>2.关于</h3><p>更多关于<a href="https://hexo.io/docs" target="_blank" rel="noopener">hexo</a>的使用可以到官网查看！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;This is a demo for studying to write blog by markdown, welcome to my &lt;a href=&quot;https://github.com/servother&quot; target=&quot;_bl
      
    
    </summary>
    
      <category term="PHP" scheme="http://cotcloud.cn/categories/PHP/"/>
    
    
      <category term="php" scheme="http://cotcloud.cn/tags/php/"/>
    
  </entry>
  
</feed>
