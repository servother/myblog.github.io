<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览一个页面发生的事]]></title>
    <url>%2F2018%2F10%2F31%2F%E8%B6%A3%E8%B0%88%E6%B5%8F%E8%A7%88%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[在浏览器出入URL到显示页面的过程先看下面一张图：123451. 当用户在浏览器输入一个URL后，浏览器会利用DNS协议查找域名对应的ip，这时找到了要连接的服务器；2. 然后浏览器通过http协议生成一个http请求报文，并向web服务器发送这个http请求报文，期间通过tcp协议与服务器建立连接；3. 与服务器建立连接后，在网络层通过ip协议发送数据，ip数据包在路由之间使用OPSF协议进行路由选择，路由器在于服务器通信时，需要使用ARP协议将ip地址转成MAC地址；4. 服务器通过TCP协议接收到请求和通过http协议处理请求，同样通过http协议生成要返回的HTML页面和使用TCP协议返回页面内容。5. 浏览器接收到页面内容，渲染页面。 这张图也简单解释了各个协议与HTTP协议的关系。 OSI七层体系和TCP/IP体系 OSI七层体系 应用层 表示层 会话层 运输层 网络层 数据链路层 物理层 TCP/IP体系 应用层（对应OSI中的上三层：应用层、表示层、会话层；各种应用层协议如http,smtp,ftp,telnet协议等） 运输层（TCP，UDP协议） 网络层（IP层） 网络接口层（对应OSI中的最下面两层：数据链路层、物理层） 五层体系 应用层 运输层 网络层 数据链路层 物理层 相对于OSI和TCP/IP体系，提出的一种折中的描述。其实就是将TCP/IP体系的网络接口层还原成数据链路层和物理层了，这样结合两种体系的描述相对更好理解。 状态码123451XX：信息性状态码。如：接收的请求正在处理。2XX：成功状态码。如：请求成功处理。3XX：重定向状态码。如：需要附加操作以完成请求。4XX：客户端错误码。如：服务器无法进行操作。5XX：服务器错误码。如：服务器处理请求出错。 HTTP中的长连接和短连接在HTTP/1.0中默认使用短连接，即客户端和服务器每进行一次http操作，就建立一次连接，任务结束就断开连接。如果客户端请求的HTML中包含其他web资源（如js文件，css文件，图片等），每有一个其他的web资源都会新建一个http会话。而从HTTP/1.1起，默认使用长连接。使用长连接的HTTP协议，会在响应头中加入这行代码Connection:keep-alivekeep-alive也不是永久保持连接的，这个保持时间是在服务器（如apache）中进行设置的，同时长连接需要客户端和服务器都支持。HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。具体关于长短连接的介绍可点击这里]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络间进程通讯之socket]]></title>
    <url>%2F2018%2F10%2F30%2F%E4%BA%86%E8%A7%A3socket%2F</url>
    <content type="text"><![CDATA[socket通讯原理网络间进程如何进行通讯本地的进程间通讯我们知道有很多种实现方式，可以总结为这四类：消息传递（管道，FIFO，消息队列），同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量），共享内存，远程过程调用。那么网络间进程通讯如何实现呢？解决这个问题，我们首先要思考如何唯一标识网络间的进程。在本地进程间，可以通过PID来唯一标识，但在网络间这明显是行不通。其实tcp/ip协议簇已经帮我们解决了这个问题，通过网络层的ip协议帮助我们确定网络间的唯一主机，而传输层的“协议+端口”可以确定主机中唯一的应用程序（进程）。这样利用（ip，协议，端口）三元数组就能唯一标识网络间的进程了。使用tcp/ip协议簇的应用程序通常都采用应用编程接口（socket和TLI）来进行通讯。而TLI这种似乎已经被淘汰了，现在基本都是使用的socket实现通讯。 什么是socket？socket一词源于UNIX，而UNIX的哲学理论就是“一切皆是文件，都可以通过open、write、read、close模式来操作”。所以socket其实就是一个“文件”。也是通过一些实现open，write，read，close操作的函数使用socket。 常用的操作socket的函数socket(int domain, int type, int protocol)socket()函数，对应于常用的打开文件的函数。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。正如fopen()函数一样，socket()函数也需要传入一定的参数来创建特定的socket描述符。 1. domain参数指定socket的协议簇，协议簇决定了socket的地址类型。例如AF_INET决定了要用Ipv4地址(32位的)和端口号(16位的)组合的地址类型。还有诸如AF_INET6、AF_LOCAL等就不细说了。 2. type参数指定socket的类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。 3. protocol参数顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等。 其中type和protocol不是随意进行组合的。当我们调用socket()函数创建一个socket描述符时，返回的描述符是存在于协议簇中的，没有一个具体的地址。如果想要给描述符赋值一个地址，我们必须调用bind()函数，否则我们调用listen(),connect()函数时，系统会随机分配一个端口。 bind(int sockfd, _ *addr, _ *addrLen)bind()函数,上面我们说到，通过socket()函数创建的socket是没有具体地址的，而我们想要给它赋值一个地址就需要调用bind()函数。 1. sockfd参数，socket描述符。通过socket()函数创建的socket描述符。 2. addr参数，给socket描述符绑定的协议地址。这个协议地址跟调用socket()函数传入的协议簇是对应相关的。 3. addrLen参数，协议地址长度。 通常服务器在启动时都会绑定一个协议地址（ip+端口），以便提供服务，客户端通过连接这个协议地址来连接服务器；而客户端则不用，由系统随机产生一个端口号和自身ip组合。 listen(int sockfd, int backlog)listen()函数。通常socket()函数创建的socket是主动类型的，通过listen()函数将socket变成被动类型，等待客户端来连接。 1. sockfd参数，被监听的socket描述符。 2. backlog参数，被监听的socket可以排队的最大连接个数。 通常作为一个服务器，在调用完socket()，bind()函数后，就会调用listen()来监听socket，如果有客户端调用connect()函数发出连接请求，服务器就会接受到这个请求。 connect(int sockfd, _ *addrSrv, int addrLen)connect()函数。客户端调用该函数向服务器发出连接请求，等待服务器响应。 1. sockfd参数，客户端的socket描述符。 2. addrSrv参数，服务器的socket地址。 3. addrLen参数，socket地址的长度。 accept(int sockfd, _ *addr, _ *addrLen)accept()函数。当服务器调用socket(),bind(),listen()函数后就会监听生成的socket地址,客户端调用socket(),connect()函数后就会向服务器发出连接请求，服务器监听到这个连接请求后，就会调用accept()函数去接收客户端的连接请求。到此服务器和客户端就连接上了，之后就是进行i/o操作。 1. sockfd参数，服务器创建的socket描述符。 2. addr参数，指向一个结构体类型的指针。用于返回客户端的协议地址。 3. addrLen参数，协议地址的长度。 如果accept()成功，则返回一个由内核生成的新的描述符，表示与返回客户端的连接。12345说明：accept()函数的第一个参数是服务器调用socket()函数创建的“被监听socket描述符”；而accept()函数调用成功后返回的是“已连接描述符”。“被监听socket描述符”通常只在服务器启动时仅仅创建一个，它在该服务器的生命周期内一直存在。而“已连接描述符”是由内核为每一个（服务器接受了客户端的连接）连接创建的描述符，在服务器完成了对某个客户端的服务后，相应的“已连接描述符”就会被关闭。 read()/write()等函数read函数是负责从fd中读取内容read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。 write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。 close(int sockfd)close()函数。在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。 1. sockfd参数，已连接描述符。 close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 TCP三次握手建立连接详解我们知道TCP建立连接需要进行三次握手，即收发三组数据。大致流程为： 1. 客户端向服务器发起连接，发送一个SYN j； 2. 服务器响应客户端一个SYN k，并对接受的SYN j 确认ACK j+1； 3. 客户端向服务器响应，并对接受的SYN k 确认ACK k+1。 从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令学习之ps]]></title>
    <url>%2F2018%2F10%2F19%2FLinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E4%B9%8Bps%2F</url>
    <content type="text"><![CDATA[ps命令详解Linux上进程有五种状态 运行（正在运行或在运行队列中等待） 中断（休眠中，受阻，在等待某个条件的行程或接受到信号） 不可中断 僵死（进程已经终止，但进程描述符存在） 停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行） ps工具标识进程的五种状态码 D：不可中断 R：运行中 S：中断 T：停止 Z：僵死 ps命令名称：ps使用权限：所有使用者使用方式：ps /[options/] /[–help/]说明：显示瞬间进程的动态参数：12345//ps的参数较多，以下仅列出常用几个-A 列出所有进程-w 显示加宽可以显示更多的信息-au 显示较详细的信息-aux 显示所有包含其他使用者的进程信息 举例说明au(x)所显示的每列所指内容。-aux的输出格式:USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND每列所指内容分别为：1234567891011USER：进程拥有者PID：进程ID%CPU：占用的CPU使用率%MEM：占用的内存使用率VSZ：占用的虚拟内存大小RSS：占用的磁盘大小TTY：进程所属的终端控制台STAT：进程状态码（下面有详细说明）START：进程开始时间TIME：执行时间COMMAND：执行的命令 其中进程状态码有以下等：123456789D: 不可中断的静止 R: 正在执行中 S: 静止状态 T: 暂停执行 Z: 不存在但暂时无法消除，僵死状态 W: 没有足够的记忆体分页可分配 &lt;: 高优先序的进程 N: 低优先序的进程 L: 有记忆体分页分配并锁在记忆体内 最常用的方法是ps -aux,然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。 与top的区别ps是提供给你当前进程的快照，而top是即时显示活跃的进程。更多top相关的命令可查阅top命令的文章]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo引用图片]]></title>
    <url>%2F2018%2F10%2F18%2Ftest-img%2F</url>
    <content type="text"><![CDATA[hexo引用图片安装插件npm install https://github.com/CodeFalling/hexo-asset-image --save 使用语法跟正常的Markdown引用图片一样，只是路径使用的是相对路径。在你安装插件之后，使用hexo new &quot;新博客&quot;生成新博客时。_post文件夹下会有个跟新博客同名的文件夹，该文件夹下就是用来放置你引用的图片的。在博客中你可以这样使用xxxx![图片名称](文件夹名称/图片名称 &quot;图片标题&quot;)xxxx，xxxx指的是你的博客内容，图片名称就是显示在图片下面的名称，图片标题就是鼠标放上去显示的文字。例如我使用![我是图片](test-img/1.jpg &quot;测试图片&quot;)，实现效果为：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下修改主机名]]></title>
    <url>%2F2018%2F10%2F18%2FLinux%E4%B8%8B%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Linux下修改主机名hostname + 主机名这种修改只是暂时有效，在当前Linux运行期间有效。重启后就失效了。 修改/etc/hosts这种方法文件里的主机名只是用来提供给dns解析的.如果你用不上dns,只需要修改主机名,那修改这个没用。 修改这个文件etc/sysconfig/network里的主机名这种方法可以实现永久修改主机名，需要重启Linux后才能生效。12NETWORKING=yesHOSTNAME=主机名 总结： #hostname 新主机名 修改/etc/sysconfig/network中的hostname的值 修改/etc/hosts文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多电脑发布hexo博客]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%A4%9A%E7%94%B5%E8%84%91%E5%8F%91%E5%B8%83hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[多电脑发布hexo博客准备github账号在github上注册账号，并新建仓库。 安装nodejs按照网上的教程安装nodejs和hexo，教程很多不赘述了。 github上新建分支，将部署源码提交上去在博客库新建分支xxx，例如笔者命名为hexo分支，将部署源码提交上去。这里需要修改.gitignore文件，将不必要提交的本地配置等文件加进去。 另一台电脑安装hexo，clone部署源码另一台电脑安装和部署好hexo的环境，配置好Git，clone部署源码，就可以协同发布了。 #总结现在一个电脑上提交部署源码到git上，后面就是在git上协同发布博客的操作。电脑A123git add .git commit -m "提交部署源码"git push origin hexo //初次将部署源码提交上hexo分支 电脑B1234git pull //先更新下本地内容，再修改，再提交git add .git commit -m ""git push origin hexo 电脑A1234git pull //先更新下本地内容，再修改，再提交git add .git commit -m ""git push origin hexo]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq实例]]></title>
    <url>%2F2018%2F10%2F08%2Frabbitmq%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ入门]]></title>
    <url>%2F2018%2F10%2F08%2Frabbitmq%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[概念说明名词介绍Broker：简单来说就是消息队列服务器实体。Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。Queue：消息队列载体，每个消息都会被投入到一个或多个队列。Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。Routing Key：路由关键字，exchange根据这个关键字进行消息投递。vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。producer：消息生产者，就是投递消息的程序。consumer：消息消费者，就是接受消息的程序。channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。 流程说明消息队列的使用过程大概如下：(1)客户端连接到消息队列服务器，打开一个channel。(2)客户端声明一个exchange，并设置相关属性。(3)客户端声明一个queue，并设置相关属性。(4)客户端使用routing key，在exchange和queue之间建立好绑定关系。(5)客户端投递消息到exchange。 exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”*”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*”只匹配”abc.def”。还有一种不需要key的，叫做Fanout交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。 RabbitMQ支持消息的持久化，也就是数据写在磁盘上，为了数据安全考虑，我想大多数用户都会选择持久化。消息队列持久化包括3个部分：(1)exchange持久化，在声明时指定durable =&gt; 1(2)queue持久化，在声明时指定durable =&gt; 1(3)消息持久化，在投递时指定delivery_mode =&gt; 2（1是非持久化）如果exchange和queue都是持久化的，那么它们之间的binding也是持久化的。如果exchange和queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。 安装略]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql嵌套事务的隐式提交]]></title>
    <url>%2F2018%2F10%2F08%2Fmysql%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[mysql官方文档是表明不支持嵌套事务的。在一个事务中开启另一个事务，会隐式commit外层事务。 示例新建一个测试表（建表SQL略），表名：demo，字段：id（自增），txt。开启事务如下：123456START TRANSACTION;INSERT INTO demo (txt) VALUES ('job');START TRANSACTION;INSERT INTO demo (txt) VALUES ('cook');COMMIT;ROLLBACK; 当你只执行前两句SQL时，此时观察表中并没有txt为job的数据。当你执行前三句你会发现表中已经有了txt为job的数据。 相关还有以下一些关键词会触发mysql的隐式提交。123456789101112131415161718192021ALTER FUNCTION ALTER PROCEDURE ALTER TABLE BEGIN CREATE DATABASE CREATE FUNCTION CREATE INDEX CREATE PROCEDURE CREATE TABLE DROP DATABASE DROP FUNCTION DROP INDEX DROP PROCEDURE DROP TABLE UNLOCK TABLES LOAD MASTER DATA LOCK TABLES RENAME TABLE TRUNCATE TABLE SET AUTOCOMMIT=1 START TRANSACTION]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE破解教程]]></title>
    <url>%2F2018%2F10%2F08%2FIDE%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[分享一个IDE破解教程，我是网址 修改hosts文件win下找到hosts文件，在hosts文件中添加“0.0.0.0 account.jetbrains.com”这行内容。Mac直接在终端使用vim编辑1$ vi /etc/hosts 复制注册码打开网址，点击获取注册码，copy过去就OK了]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>ide</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门]]></title>
    <url>%2F2018%2F04%2F20%2Fdemo%2F</url>
    <content type="text"><![CDATA[This is a demo for studying to write blog by markdown, welcome to my github! 简单入门1.命令创建新文章1$ hexo new "文章名" //创建新的博客文章 发布文章123//当你编辑完新的文章，需要下面的命令更新并发布到github上$ hexo clean $ hexo g -d 2.关于更多关于hexo的使用可以到官网查看！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
</search>
