<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[谈谈IOC/DI]]></title>
    <url>%2F2018%2F11%2F06%2F%E8%B0%88%E8%B0%88IOC-DI%2F</url>
    <content type="text"><![CDATA[谈谈IOC/DI]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊缓存-Redis]]></title>
    <url>%2F2018%2F11%2F05%2F%E8%81%8A%E8%81%8A%E7%BC%93%E5%AD%98-Redis%2F</url>
    <content type="text"><![CDATA[分布式缓存Redis为什么使用Redis？使用Redis主要是考虑项目的性能和并发。从性能上来说：当我们执行一个繁琐但是不经常变动的SQL时，重复的浪费时间在执行SQL上了，此时加上缓存就可以直接访问缓存，大大节约了访问数据库的时间。从并发性上说：当很多个连接去访问数据库，数据库很容易出现异常等问题。当然还有Redis具有分布式锁等等优点。 单线程的Redis为什么这么快？首先，Redis是常驻内存进程，纯内存操作，你说能不快吗。第二，Redis是单线程操作，避免频繁的上下文切换。第三，Redis采用非阻塞I/O多路复用机制，可百度详细介绍，作深入了解←_← Redis的数据类型及常用场景 String。最常规的set/get操作，可存储value可以是string也可以是数字。一般做一些复杂的计数功能的缓存。 Hash。特别适合用于存储对象。有些单点登录的实现，就是借助Redis的Hash缓存cookID和对应的用户信息。 List。字符串列表，按照插入顺序排序。这种数据类型可以做一些简单的队列，也可以利用lrange实现redis的分页功能。 Set。因为set堆放的是一些不可重复值的集合。可以做去重的作用。 Sorted Set。相对于Set，多了一个权重参数sorce。可以根据sorce进行排序，例如排行榜等。 Redis的过期策略和内存淘汰机制我们已经知道Redis是在内存中工作的，如果一直不停的往Redis写数据，那内存很快就不够用了，所以需要进行删除。一般来说，删除策略有三种：立即删除，惰性删除，定时删除。立即删除：键值一过期就进行删除，保证了缓存最大的鲜活度，但是对CPU却不友好。删除是需要CPU时间的，如果CPU在高峰期，此时还要进行删除操作，无疑添加了CPU的负荷。惰性删除：到了过期时间不会立即删除，而是下次使用到了进行删除，显而易见，这种方式浪费了内存空间。定时删除：这是一种折中于上面两者之间的策略。每隔一段时间进行删除操作，并通过限制删除操作的时长和频率来减少对CPU的影响。而Redis采用定时删除+惰性删除。使用这种删除策略就一定没有问题吗，很明显不是的。如果定时删除没有删除key，你也长时间没有访问该key，那么还是白白浪费了内存空间。这时就要提到内存淘汰机制。在redis.conf配置文件中有这么一行配置：# maxmemory-policy volatile-lru该配置就是用来配置内存淘汰机制的。 noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。 allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。 注意：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。 Redis会有那些缺点？任何事物都不可能是完美的，使用Redis也会出现一些问题。比如下面这些： 缓存和数据库双写一致性问题。 缓存穿透问题。 缓存雪崩问题。 缓存的并发竞争问题。 有问题我们就需要解决。 缓存和数据库双写一致性问题一致性问题是分布式最常见的问题。一致性有可细分为最终一致性和强一致性。对于强一致性的数据，是不建议放缓存的，我们做的一切只能保证最终一致性。所以我们只能做好更新策略，先更新数据库，再删除缓存。对于缓存删除失败可以使用消息队列来做补偿措施。 缓存穿透问题当有黑客故意发出大量请求缓存中不存在的数据时，就会发生缓存穿透，导致大量请求怼到数据库，造成数据库异常。对应的解决方案： 利用互斥锁：缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。 采用异步更新策略，无论 Key 是否取到值，都直接返回。 提供一个能迅速判断请求是否有效的拦截机制：常用的如布隆过滤器，虽然不能保证百分百的过滤，但是很适合作为第一道门槛。 缓存雪崩问题当有一大片缓存同时失效，而同时有来了一堆请求，就会出现大量请求直接访问到数据库，操作数据库异常。对应的解决方案： 给缓存的失效时间，加上一个随机值，避免集体失效。 使用互斥锁，很明显这种容易造成吞吐量下降。 双缓存。 缓存的并发竞争问题这种情况类似于有多个子系统要set同一个key。百度很多说是利用redis事务机制来解决，单机可能有用，但是在redis集群中，数据做了分片就显得十分麻烦。对于无顺序要求的，使用分布式锁，抢到锁就进行set，这种比较简单。对于有顺序的，一种抢到锁进行set操作同时加上时间戳，如A要set这个key的value为a，B要set value为b，C要set value为c，在写入数据库的时候我们带上一个时间戳123系统A key（value a 11:00）系统B key（value b 11:01）系统C key（value c 11:02） 假如B先抢到锁，执行完set操作，此时A抢到锁，发现自己的时间戳早于此时B已经写入的时间戳，那么不进行set操作。还有一种就是利用队列的串行实现顺序操作。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令学习之vi]]></title>
    <url>%2F2018%2F11%2F02%2FLinux%E5%91%BD%E4%BB%A4%E4%B9%8Bvi%2F</url>
    <content type="text"><![CDATA[Linux命令学习之vi一、vi的基本操作 进入vi。在系统提示符号后输入$vi filename，就进入了vi编辑画面。需要注意得是，一进来是命令行模式。 切换到插入模式进行插入文字的操作。在命令行模式按下“i”就切换到插入模式了。需要注意的是，当你前面输错字了是不能直接删除的，这时需要切换回命令行模式删除。 插入模式切换回命令行模式。在插入模式下按“esc”就可以切换回命令行模式了。 退出vi并保存文件。在命令行模式下输入:123:w filename //将文件以filename为文件名保存，并退出vi:wq //将文件保存并退出vi:q! //强制退出vi，不会保存任何修改的内容 二、命令行模式功能键插入模式按“i”切换进入插入模式，此时是从光标所在位置开始插入数据；按“a”切换进入插入模式，是从光标所在位置的下一个位置开始插入数据；按“o”切换进入插入模式，是插入新的一行，从行首开始插入数据。 从插入模式切换到命令行模式按“esc”从插入模式切换到命令行模式。 移动光标12345678910111213一般都是可以直接通过上下左右键移动光标，正规的也有通过“h,j,k,l”来移动光标“左，下，上，右”。按“Ctrl”+“b”：屏幕往“后”移动一页。按“Ctrl”+“f”：屏幕往“前”移动一页。按“Ctrl”+“u”：屏幕往“后”移动半页。按“Ctrl”+“d”：屏幕往“前”移动半页。按数字“0”：光标移动到文件开头。按“g”：光标移动到文件末尾。按“$”：光标移动到行尾。按“^”：光标移动到行头。按“w”：光标移动到下个字的字头。按“e”：光标移动到下个字的字尾。按“b”：光标回到上个字的字头。按“数字”+“l”：光标移动到当前行的第几个位置。如“33l”。 删除文字123456按“x”：删除光标所在位置的后面的文字，类似“DEL”键删除文字。注意小写是删除后面的！按“数字”+“x”：删除光标所在位置后的“数字”个文字。按“X”：删除光标所在位置的前面的文字，类似“backspace”键删除文字。注意大写是删除前面的！按“数字”+“X”：删除光标所在位置前的“数字”个文字。按“dd”：删除光标所在行。按“数字”+“dd”：从光标所在行开始删除“数字”行。 复制123456按“yw”：将光标所在之处到字尾的文字复制到缓冲区。按“数字”+“yw”：复制N个数字到缓冲区。按“yy”：复制光标所在行到缓冲区。按“数字”+“yy”：从光标所在行开始往下数N行复制到缓冲区。按“p”：将缓冲区的内容复制到光标所在位置。//通常都是y和p配合完成复制粘贴 替换12按“r”：替换光标所**在**之处的字符。按“R”：替换光标所**到**之处的字符，直到按下“esc”键为止。 撤销一次命令1按“u”：可撤销一次命令，按多次可撤销多次命令。 更改12按“cw”：更改光标所在处的字到字尾处。按“c数字w”：表示更改从光标所在处开始的N个字到字尾处。 跳到指定的行12按“Ctrl”+“g”：显示出光标所在行的行号。按“数字”+“G”：跳到文件的第N行行首。 ：模式（Last line mode）下功能键首先确定你在命令行模式下，按“:”进入last line mode该模式下。也可以理解为以下命令前都加上一个冒号，然后回车来实现相应操作，特别说明下面的只写了冒号后面的命令名。1234567接“set nu”：会显示文件中所有行的行号。接“数字”：会跳到文章的第N行。接“/”+“关键字”：会进行查找文件中的“关键字”，类似Ctrl+F搜索文字功能。按“n”寻找下一个。接“?”+“关键字”：一样查找关键字，但是再按“n”是向上寻找关键字。接“w”：保存文件。接“q”：退出vi。如果无法退出，可q后再接“!”强制退出。接“wq”：保存文件并退出vi。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览一个页面发生的事]]></title>
    <url>%2F2018%2F10%2F31%2F%E8%B6%A3%E8%B0%88%E6%B5%8F%E8%A7%88%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[在浏览器出入URL到显示页面的过程先看下面一张图：123451. 当用户在浏览器输入一个URL后，浏览器会利用DNS协议查找域名对应的ip，这时找到了要连接的服务器；2. 然后浏览器通过http协议生成一个http请求报文，并向web服务器发送这个http请求报文，期间通过tcp协议与服务器建立连接；3. 与服务器建立连接后，在网络层通过ip协议发送数据，ip数据包在路由之间使用OPSF协议进行路由选择，路由器在于服务器通信时，需要使用ARP协议将ip地址转成MAC地址；4. 服务器通过TCP协议接收到请求和通过http协议处理请求，同样通过http协议生成要返回的HTML页面和使用TCP协议返回页面内容。5. 浏览器接收到页面内容，渲染页面。 这张图也简单解释了各个协议与HTTP协议的关系。 OSI七层体系和TCP/IP体系 OSI七层体系 应用层 表示层 会话层 运输层 网络层 数据链路层 物理层 TCP/IP体系 应用层（对应OSI中的上三层：应用层、表示层、会话层；各种应用层协议如http,smtp,ftp,telnet协议等） 运输层（TCP，UDP协议） 网络层（IP层） 网络接口层（对应OSI中的最下面两层：数据链路层、物理层） 五层体系 应用层 运输层 网络层 数据链路层 物理层 相对于OSI和TCP/IP体系，提出的一种折中的描述。其实就是将TCP/IP体系的网络接口层还原成数据链路层和物理层了，这样结合两种体系的描述相对更好理解。 状态码123451XX：信息性状态码。如：接收的请求正在处理。2XX：成功状态码。如：请求成功处理。3XX：重定向状态码。如：需要附加操作以完成请求。4XX：客户端错误码。如：服务器无法进行操作。5XX：服务器错误码。如：服务器处理请求出错。 HTTP中的长连接和短连接在HTTP/1.0中默认使用短连接，即客户端和服务器每进行一次http操作，就建立一次连接，任务结束就断开连接。如果客户端请求的HTML中包含其他web资源（如js文件，css文件，图片等），每有一个其他的web资源都会新建一个http会话。而从HTTP/1.1起，默认使用长连接。使用长连接的HTTP协议，会在响应头中加入这行代码Connection:keep-alivekeep-alive也不是永久保持连接的，这个保持时间是在服务器（如apache）中进行设置的，同时长连接需要客户端和服务器都支持。HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**具体关于长短连接的介绍可点击这里**]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络间进程通讯之socket]]></title>
    <url>%2F2018%2F10%2F30%2F%E4%BA%86%E8%A7%A3socket%2F</url>
    <content type="text"><![CDATA[socket通讯原理网络间进程如何进行通讯本地的进程间通讯我们知道有很多种实现方式，可以总结为这四类：消息传递（管道，FIFO，消息队列），同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量），共享内存，远程过程调用。那么网络间进程通讯如何实现呢？解决这个问题，我们首先要思考如何唯一标识网络间的进程。在本地进程间，可以通过PID来唯一标识，但在网络间这明显是行不通。其实tcp/ip协议簇已经帮我们解决了这个问题，通过网络层的ip协议帮助我们确定网络间的唯一主机，而传输层的“协议+端口”可以确定主机中唯一的应用程序（进程）。这样利用（ip，协议，端口）三元数组就能唯一标识网络间的进程了。使用tcp/ip协议簇的应用程序通常都采用应用编程接口（socket和TLI）来进行通讯。而TLI这种似乎已经被淘汰了，现在基本都是使用的socket实现通讯。 什么是socket？socket一词源于UNIX，而UNIX的哲学理论就是“一切皆是文件，都可以通过open、write、read、close模式来操作”。所以socket其实就是一个“文件”。也是通过一些实现open，write，read，close操作的函数使用socket。 常用的操作socket的函数socket(int domain, int type, int protocol)socket()函数，对应于常用的打开文件的函数。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。正如fopen()函数一样，socket()函数也需要传入一定的参数来创建特定的socket描述符。 1. domain参数指定socket的协议簇，协议簇决定了socket的地址类型。例如AF_INET决定了要用Ipv4地址(32位的)和端口号(16位的)组合的地址类型。还有诸如AF_INET6、AF_LOCAL等就不细说了。 2. type参数指定socket的类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。 3. protocol参数顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等。 其中type和protocol不是随意进行组合的。当我们调用socket()函数创建一个socket描述符时，返回的描述符是存在于协议簇中的，没有一个具体的地址。如果想要给描述符赋值一个地址，我们必须调用bind()函数，否则我们调用listen(),connect()函数时，系统会随机分配一个端口。 bind(int sockfd, _ *addr, _ *addrLen)bind()函数,上面我们说到，通过socket()函数创建的socket是没有具体地址的，而我们想要给它赋值一个地址就需要调用bind()函数。 1. sockfd参数，socket描述符。通过socket()函数创建的socket描述符。 2. addr参数，给socket描述符绑定的协议地址。这个协议地址跟调用socket()函数传入的协议簇是对应相关的。 3. addrLen参数，协议地址长度。 通常服务器在启动时都会绑定一个协议地址（ip+端口），以便提供服务，客户端通过连接这个协议地址来连接服务器；而客户端则不用，由系统随机产生一个端口号和自身ip组合。 listen(int sockfd, int backlog)listen()函数。通常socket()函数创建的socket是主动类型的，通过listen()函数将socket变成被动类型，等待客户端来连接。 1. sockfd参数，被监听的socket描述符。 2. backlog参数，被监听的socket可以排队的最大连接个数。 通常作为一个服务器，在调用完socket()，bind()函数后，就会调用listen()来监听socket，如果有客户端调用connect()函数发出连接请求，服务器就会接受到这个请求。 connect(int sockfd, _ *addrSrv, int addrLen)connect()函数。客户端调用该函数向服务器发出连接请求，等待服务器响应。 1. sockfd参数，客户端的socket描述符。 2. addrSrv参数，服务器的socket地址。 3. addrLen参数，socket地址的长度。 accept(int sockfd, _ *addr, _ *addrLen)accept()函数。当服务器调用socket(),bind(),listen()函数后就会监听生成的socket地址,客户端调用socket(),connect()函数后就会向服务器发出连接请求，服务器监听到这个连接请求后，就会调用accept()函数去接收客户端的连接请求。到此服务器和客户端就连接上了，之后就是进行i/o操作。 1. sockfd参数，服务器创建的socket描述符。 2. addr参数，指向一个结构体类型的指针。用于返回客户端的协议地址。 3. addrLen参数，协议地址的长度。 如果accept()成功，则返回一个由内核生成的新的描述符，表示与返回客户端的连接。12345说明：accept()函数的第一个参数是服务器调用socket()函数创建的“被监听socket描述符”；而accept()函数调用成功后返回的是“已连接描述符”。“被监听socket描述符”通常只在服务器启动时仅仅创建一个，它在该服务器的生命周期内一直存在。而“已连接描述符”是由内核为每一个（服务器接受了客户端的连接）连接创建的描述符，在服务器完成了对某个客户端的服务后，相应的“已连接描述符”就会被关闭。 read()/write()等函数read函数是负责从fd中读取内容read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。 write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。 close(int sockfd)close()函数。在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。 1. sockfd参数，已连接描述符。 close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 TCP三次握手建立连接详解我们知道TCP建立连接需要进行三次握手，即收发三组数据。大致流程为： 1. 客户端向服务器发起连接，发送一个SYN j； 2. 服务器响应客户端一个SYN k，并对接受的SYN j 确认ACK j+1； 3. 客户端向服务器响应，并对接受的SYN k 确认ACK k+1。 从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令学习之ps]]></title>
    <url>%2F2018%2F10%2F19%2FLinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E4%B9%8Bps%2F</url>
    <content type="text"><![CDATA[ps命令详解Linux上进程有五种状态 运行（正在运行或在运行队列中等待） 中断（休眠中，受阻，在等待某个条件的行程或接受到信号） 不可中断 僵死（进程已经终止，但进程描述符存在） 停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行） ps工具标识进程的五种状态码 D：不可中断 R：运行中 S：中断 T：停止 Z：僵死 ps命令名称：ps使用权限：所有使用者使用方式：ps /[options/] /[–help/]说明：显示瞬间进程的动态参数：12345//ps的参数较多，以下仅列出常用几个-A 列出所有进程-w 显示加宽可以显示更多的信息-au 显示较详细的信息-aux 显示所有包含其他使用者的进程信息 举例说明au(x)所显示的每列所指内容。-aux的输出格式:USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND每列所指内容分别为：1234567891011USER：进程拥有者PID：进程ID%CPU：占用的CPU使用率%MEM：占用的内存使用率VSZ：占用的虚拟内存大小RSS：占用的磁盘大小TTY：进程所属的终端控制台STAT：进程状态码（下面有详细说明）START：进程开始时间TIME：执行时间COMMAND：执行的命令 其中进程状态码有以下等：123456789D: 不可中断的静止 R: 正在执行中 S: 静止状态 T: 暂停执行 Z: 不存在但暂时无法消除，僵死状态 W: 没有足够的记忆体分页可分配 &lt;: 高优先序的进程 N: 低优先序的进程 L: 有记忆体分页分配并锁在记忆体内 最常用的方法是ps -aux,然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。 与top的区别ps是提供给你当前进程的快照，而top是即时显示活跃的进程。更多top相关的命令可查阅top命令的文章]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo引用图片]]></title>
    <url>%2F2018%2F10%2F18%2Ftest-img%2F</url>
    <content type="text"><![CDATA[hexo引用图片安装插件npm install https://github.com/CodeFalling/hexo-asset-image --save 使用语法跟正常的Markdown引用图片一样，只是路径使用的是相对路径。在你安装插件之后，使用hexo new &quot;新博客&quot;生成新博客时。_post文件夹下会有个跟新博客同名的文件夹，该文件夹下就是用来放置你引用的图片的。在博客中你可以这样使用xxxx![图片名称](文件夹名称/图片名称 &quot;图片标题&quot;)xxxx，xxxx指的是你的博客内容，图片名称就是显示在图片下面的名称，图片标题就是鼠标放上去显示的文字。例如我使用![我是图片](test-img/1.jpg &quot;测试图片&quot;)，实现效果为：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下修改主机名]]></title>
    <url>%2F2018%2F10%2F18%2FLinux%E4%B8%8B%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Linux下修改主机名hostname + 主机名这种修改只是暂时有效，在当前Linux运行期间有效。重启后就失效了。 修改/etc/hosts这种方法文件里的主机名只是用来提供给dns解析的.如果你用不上dns,只需要修改主机名,那修改这个没用。 修改这个文件etc/sysconfig/network里的主机名这种方法可以实现永久修改主机名，需要重启Linux后才能生效。12NETWORKING=yesHOSTNAME=主机名 总结： #hostname 新主机名 修改/etc/sysconfig/network中的hostname的值 修改/etc/hosts文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多电脑发布hexo博客]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%A4%9A%E7%94%B5%E8%84%91%E5%8F%91%E5%B8%83hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[多电脑发布hexo博客准备github账号在github上注册账号，并新建仓库。 安装nodejs按照网上的教程安装nodejs和hexo，教程很多不赘述了。 github上新建分支，将部署源码提交上去在博客库新建分支xxx，例如笔者命名为hexo分支，将部署源码提交上去。这里需要修改.gitignore文件，将不必要提交的本地配置等文件加进去。 另一台电脑安装hexo，clone部署源码另一台电脑安装和部署好hexo的环境，配置好Git，clone部署源码，就可以协同发布了。 #总结现在一个电脑上提交部署源码到git上，后面就是在git上协同发布博客的操作。电脑A123git add .git commit -m "提交部署源码"git push origin hexo //初次将部署源码提交上hexo分支 电脑B1234git pull //先更新下本地内容，再修改，再提交git add .git commit -m ""git push origin hexo 电脑A1234git pull //先更新下本地内容，再修改，再提交git add .git commit -m ""git push origin hexo]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq实例]]></title>
    <url>%2F2018%2F10%2F08%2Frabbitmq%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ入门]]></title>
    <url>%2F2018%2F10%2F08%2Frabbitmq%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[概念说明名词介绍Broker：简单来说就是消息队列服务器实体。Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。Queue：消息队列载体，每个消息都会被投入到一个或多个队列。Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。Routing Key：路由关键字，exchange根据这个关键字进行消息投递。vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。producer：消息生产者，就是投递消息的程序。consumer：消息消费者，就是接受消息的程序。channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。 流程说明消息队列的使用过程大概如下：(1)客户端连接到消息队列服务器，打开一个channel。(2)客户端声明一个exchange，并设置相关属性。(3)客户端声明一个queue，并设置相关属性。(4)客户端使用routing key，在exchange和queue之间建立好绑定关系。(5)客户端投递消息到exchange。 exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”*”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*”只匹配”abc.def”。还有一种不需要key的，叫做Fanout交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。 RabbitMQ支持消息的持久化，也就是数据写在磁盘上，为了数据安全考虑，我想大多数用户都会选择持久化。消息队列持久化包括3个部分：(1)exchange持久化，在声明时指定durable =&gt; 1(2)queue持久化，在声明时指定durable =&gt; 1(3)消息持久化，在投递时指定delivery_mode =&gt; 2（1是非持久化）如果exchange和queue都是持久化的，那么它们之间的binding也是持久化的。如果exchange和queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。 安装略]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql嵌套事务的隐式提交]]></title>
    <url>%2F2018%2F10%2F08%2Fmysql%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[mysql官方文档是表明不支持嵌套事务的。在一个事务中开启另一个事务，会隐式commit外层事务。 示例新建一个测试表（建表SQL略），表名：demo，字段：id（自增），txt。开启事务如下：123456START TRANSACTION;INSERT INTO demo (txt) VALUES ('job');START TRANSACTION;INSERT INTO demo (txt) VALUES ('cook');COMMIT;ROLLBACK; 当你只执行前两句SQL时，此时观察表中并没有txt为job的数据。当你执行前三句你会发现表中已经有了txt为job的数据。 相关还有以下一些关键词会触发mysql的隐式提交。123456789101112131415161718192021ALTER FUNCTION ALTER PROCEDURE ALTER TABLE BEGIN CREATE DATABASE CREATE FUNCTION CREATE INDEX CREATE PROCEDURE CREATE TABLE DROP DATABASE DROP FUNCTION DROP INDEX DROP PROCEDURE DROP TABLE UNLOCK TABLES LOAD MASTER DATA LOCK TABLES RENAME TABLE TRUNCATE TABLE SET AUTOCOMMIT=1 START TRANSACTION]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE破解教程]]></title>
    <url>%2F2018%2F10%2F08%2FIDE%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[分享一个IDE破解教程，我是网址 修改hosts文件win下找到hosts文件，在hosts文件中添加“0.0.0.0 account.jetbrains.com”这行内容。Mac直接在终端使用vim编辑1$ vi /etc/hosts 复制注册码打开网址，点击获取注册码，copy过去就OK了]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>ide</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门]]></title>
    <url>%2F2018%2F04%2F20%2Fdemo%2F</url>
    <content type="text"><![CDATA[This is a demo for studying to write blog by markdown, welcome to my github! 简单入门1.命令创建新文章1$ hexo new "文章名" //创建新的博客文章 发布文章123//当你编辑完新的文章，需要下面的命令更新并发布到github上$ hexo clean $ hexo g -d 2.关于更多关于hexo的使用可以到官网查看！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
</search>
